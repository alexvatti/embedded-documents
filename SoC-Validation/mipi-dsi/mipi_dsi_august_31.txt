

/*
 * dsi phy reg write function
 */
static void dsi_phy_tst_set(void __iomem *base, u32 reg, u32 val)
{
	u32 reg_write = 0x10000 + reg;
	/*
	 * latch reg first
	 */
	writel(reg_write, base + PHY_TST_CTRL1);
	writel(0x02, base + PHY_TST_CTRL0);
	writel(0x00, base + PHY_TST_CTRL0);
	/*
	 * then latch value
	 */
	writel(val, base + PHY_TST_CTRL1);
	writel(0x02, base + PHY_TST_CTRL0);
	writel(0x00, base + PHY_TST_CTRL0);
}


static void dsi_set_phy_timer(void __iomem *base,
			      struct mipi_phy_params *phy,
			      u32 lanes)
{
	u32 val;
	/*
	 * Set lane value and phy stop wait time.
	 */
	val = (lanes - 1) | (PHY_STOP_WAIT_TIME << 8);
	writel(val, base + PHY_IF_CFG);
	/*
	 * Set phy clk division.
	 */
	val = readl(base + CLKMGR_CFG) | phy->clk_division;
	writel(val, base + CLKMGR_CFG);
	/*
	 * Set lp and hs switching params.
	 */
	dw_update_bits(base + PHY_TMR_CFG, 24, MASK(8), phy->hs2lp_time);
	dw_update_bits(base + PHY_TMR_CFG, 16, MASK(8), phy->lp2hs_time);
	dw_update_bits(base + PHY_TMR_LPCLK_CFG, 16, MASK(10),
		       phy->clkhs2lp_time);
	dw_update_bits(base + PHY_TMR_LPCLK_CFG, 0, MASK(10),
		       phy->clklp2hs_time);
	dw_update_bits(base + CLK_DATA_TMR_CFG, 8, MASK(8),
		       phy->data_to_clk_delay);
	dw_update_bits(base + CLK_DATA_TMR_CFG, 0, MASK(8),
		       phy->clk_to_data_delay);
}


static void dsi_set_mipi_phy(void __iomem *base,
			     struct mipi_phy_params *phy,
			     u32 lanes)
{
	u32 delay_count;
	u32 val;
	u32 i;
	/* phy timer setting */
	dsi_set_phy_timer(base, phy, lanes);
	/*
	 * Reset to clean up phy tst params.
	 */
	writel(0, base + PHY_RSTZ);
	writel(0, base + PHY_TST_CTRL0);
	writel(1, base + PHY_TST_CTRL0);
	writel(0, base + PHY_TST_CTRL0);
	/*
	 * Clock lane timing control setting: TLPX, THS-PREPARE,
	 * THS-ZERO, THS-TRAIL, TWAKEUP.
	 */
	dsi_phy_tst_set(base, CLK_TLPX, phy->clk_t_lpx);
	dsi_phy_tst_set(base, CLK_THS_PREPARE, phy->clk_t_hs_prepare);
	dsi_phy_tst_set(base, CLK_THS_ZERO, phy->clk_t_hs_zero);
	dsi_phy_tst_set(base, CLK_THS_TRAIL, phy->clk_t_hs_trial);
	dsi_phy_tst_set(base, CLK_TWAKEUP, phy->clk_t_wakeup);
	/*
	 * Data lane timing control setting: TLPX, THS-PREPARE,
	 * THS-ZERO, THS-TRAIL, TTA-GO, TTA-GET, TWAKEUP.
	 */
	for (i = 0; i < lanes; i++) {
		dsi_phy_tst_set(base, DATA_TLPX(i), phy->data_t_lpx);
		dsi_phy_tst_set(base, DATA_THS_PREPARE(i),
				phy->data_t_hs_prepare);
		dsi_phy_tst_set(base, DATA_THS_ZERO(i), phy->data_t_hs_zero);
		dsi_phy_tst_set(base, DATA_THS_TRAIL(i), phy->data_t_hs_trial);
		dsi_phy_tst_set(base, DATA_TTA_GO(i), phy->data_t_ta_go);
		dsi_phy_tst_set(base, DATA_TTA_GET(i), phy->data_t_ta_get);
		dsi_phy_tst_set(base, DATA_TWAKEUP(i), phy->data_t_wakeup);
	}

	writel(PHY_ENABLECLK, base + PHY_RSTZ);
	udelay(1);
	writel(PHY_ENABLECLK | PHY_UNSHUTDOWNZ, base + PHY_RSTZ);
	udelay(1);
	writel(PHY_ENABLECLK | PHY_UNRSTZ | PHY_UNSHUTDOWNZ, base + PHY_RSTZ);
	usleep_range(1000, 1500);
	/*
	 * wait for phy's clock ready
	 */
	delay_count = 100;
	while (delay_count) {
		val = readl(base +  PHY_STATUS);
		if ((BIT(0) | BIT(2)) & val)
			break;
		udelay(1);
		delay_count--;
	}
	if (!delay_count)
		DRM_INFO("phylock and phystopstateclklane is not ready.\n");
}


static void dsi_mipi_init(struct dw_dsi *dsi)
{
	struct dsi_hw_ctx *ctx = dsi->ctx;
	struct mipi_phy_params *phy = &dsi->phy;
	struct drm_display_mode *mode = &dsi->cur_mode;
	u32 bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
	void __iomem *base = ctx->base;
	u32 dphy_req_kHz;
	/*
	 * count phy params
	 */
	dphy_req_kHz = mode->clock * bpp / dsi->lanes;
	dsi_get_phy_params(dphy_req_kHz, phy);
	/* reset Core */
	writel(RESET, base + PWR_UP);

	/* set dsi phy params */
	dsi_set_mipi_phy(base, phy, dsi->lanes);

	/* set dsi mode timing */
	dsi_set_mode_timing(base, phy->lane_byte_clk_kHz, mode, dsi->format);
	/* set dsi video mode */
	dsi_set_video_mode(base, dsi->mode_flags);
	/* dsi wake up */
	writel(POWERUP, base + PWR_UP);
	DRM_DEBUG_DRIVER("lanes=%d, pixel_clk=%d kHz, bytes_freq=%d kHz\n",
			 dsi->lanes, mode->clock, phy->lane_byte_clk_kHz);
}


static void dsi_set_mode_timing(void __iomem *base,
				u32 lane_byte_clk_kHz,
				struct drm_display_mode *mode,
				enum mipi_dsi_pixel_format format)
{
	u32 hfp, hbp, hsw, vfp, vbp, vsw;
	u32 hline_time;
	u32 hsa_time;
	u32 hbp_time;
	u32 pixel_clk_kHz;
	int htot, vtot;
	u32 val;
	u64 tmp;
	val = dsi_get_dpi_color_coding(format);
	writel(val, base + DPI_COLOR_CODING);
	val = (mode->flags & DRM_MODE_FLAG_NHSYNC ? 1 : 0) << 2;
	val |= (mode->flags & DRM_MODE_FLAG_NVSYNC ? 1 : 0) << 1;
	writel(val, base +  DPI_CFG_POL);
	/*
	 * The DSI IP accepts vertical timing using lines as normal,
	 * but horizontal timing is a mixture of pixel-clocks for the
	 * active region and byte-lane clocks for the blanking-related
	 * timings.  hfp is specified as the total hline_time in byte-
	 * lane clocks minus hsa, hbp and active.
	 */
	pixel_clk_kHz = mode->clock;
	htot = mode->htotal;
	vtot = mode->vtotal;
	hfp = mode->hsync_start - mode->hdisplay;
	hbp = mode->htotal - mode->hsync_end;
	hsw = mode->hsync_end - mode->hsync_start;
	vfp = mode->vsync_start - mode->vdisplay;
	vbp = mode->vtotal - mode->vsync_end;
	vsw = mode->vsync_end - mode->vsync_start;
	if (vsw > 15) {
		DRM_DEBUG_DRIVER("vsw exceeded 15\n");
		vsw = 15;
	}
	hsa_time = (hsw * lane_byte_clk_kHz) / pixel_clk_kHz;
	hbp_time = (hbp * lane_byte_clk_kHz) / pixel_clk_kHz;
	tmp = (u64)htot * (u64)lane_byte_clk_kHz;
	hline_time = DIV_ROUND_UP(tmp, pixel_clk_kHz);
	/* all specified in byte-lane clocks */
	writel(hsa_time, base + VID_HSA_TIME);
	writel(hbp_time, base + VID_HBP_TIME);
	writel(hline_time, base + VID_HLINE_TIME);
	writel(vsw, base + VID_VSA_LINES);
	writel(vbp, base + VID_VBP_LINES);
	writel(vfp, base + VID_VFP_LINES);
	writel(mode->vdisplay, base + VID_VACTIVE_LINES);
	writel(mode->hdisplay, base + VID_PKT_SIZE);
	DRM_DEBUG_DRIVER("htot=%d, hfp=%d, hbp=%d, hsw=%d\n",
			 htot, hfp, hbp, hsw);
	DRM_DEBUG_DRIVER("vtol=%d, vfp=%d, vbp=%d, vsw=%d\n",
			 vtot, vfp, vbp, vsw);
	DRM_DEBUG_DRIVER("hsa_time=%d, hbp_time=%d, hline_time=%d\n",
			 hsa_time, hbp_time, hline_time);
}


static void dsi_set_video_mode(void __iomem *base, unsigned long flags)
{
	u32 val;
	u32 mode_mask = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
		MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
	u32 non_burst_sync_pulse = MIPI_DSI_MODE_VIDEO |
		MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
	u32 non_burst_sync_event = MIPI_DSI_MODE_VIDEO;
	/*
	 * choose video mode type
	 */
	if ((flags & mode_mask) == non_burst_sync_pulse)
		val = DSI_NON_BURST_SYNC_PULSES;
	else if ((flags & mode_mask) == non_burst_sync_event)
		val = DSI_NON_BURST_SYNC_EVENTS;
	else
		val = DSI_BURST_SYNC_PULSES_1;
	writel(val, base + VID_MODE_CFG);
	writel(PHY_TXREQUESTCLKHS, base + LPCLK_CTRL);
	writel(DSI_VIDEO_MODE, base + MODE_CFG);
}

