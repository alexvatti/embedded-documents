/*DMAC Memory to Memory test with Secure and Non Secure DMAC interface*/
#include <common.h>
#include <command.h>
#include <asm/io.h>
#include <malloc.h>
#include <asm/arch/shikhara_map.h>
#include <asm/arch/dma.h>

#define DEBUG_DMAC

#ifdef DEBUG_DMAC
#define dbg(x...)       printf(x)
#else
#define dbg(x...)       do { } while (0)
#endif

#define SECURE_DMA 	1
#define BUF_LEN		1024
#define MC_CODE_LEN	64

#define TZ 0xD456C108
static unsigned int dma_code_ns[] ={
/*
	;;The below microcode is generated by the code.
	DMAMOV CCR SB16 SP7 SS64 DB16 DP7 DS64
	DMAMOV   SAR, 0x53AFE068
	DMAMOV   DAR, 0x53AFe470
	DMALP LC1, 8 ;loop count is calculated for 1024 byte (1024/((64/8)*16)).
	DMALD
	DMAST
	DMALPEND
	DMASEV E1
	DMAEND
*/
	0xC7F701BC,
	0x00BC01FD,
	0x53AFE068,
	0xE47002BC,
	0x072253AF,
	0x023C0804,
	0xFF000834,
	0xFFFFFFFF,
};


static unsigned int dma_code_s[] = {
	0x40F901BC,
	0x00BC003E,
	0x40200000,
	0x000002BC,
	0x00324002,
	0x0B070620,
	0x2B07023B,
	0x00341300,
	0xFFFFFF00,
	0xFFFFFFFF,
	0xFFFFFFFF,
};

#define DMA_CODE1_L      10

int dmatest_ns ()
{
	unsigned int i,st;
	unsigned int data, errors = 0;
	volatile unsigned int * address;
	#if 0
	volatile unsigned int *from = (unsigned int *)malloc(BUF_LEN);
	volatile unsigned int *to = (unsigned int *)malloc(BUF_LEN);
	volatile unsigned int *mc = (unsigned int *)malloc(MC_CODE_LEN);
	#endif
	volatile unsigned int *from = (unsigned int *)0x10;
	volatile unsigned int *to = (unsigned int *)0x2000;
	volatile unsigned int *mc = (unsigned int *)0x4000;
	int pass = TRUE;


	/* Change DMA Manager to NS state */
	writel(0x400,SHIKHARA_SYS_CTRL_DMAC_CONFIG_REG);
	udelay(10);
	/*Release reset for DMAC*/
	writel(0x0,SHIKHARA_SYS_CTRL_DMAC_CONFIG_RESET);
	//Fill memory with test pattern
	data = 0x12345678;

	printf("DMA Test: Perform  Non Secure Memory to Memory Test from address 0x%X and to 0x%X \n",from,to);
	address = from;
	for (i=BUF_LEN;i>0;i=i-4)
	{
		*address = data;
		address = address + 1;
	}

	// clean destination memory
	address = to;
	for (i=BUF_LEN;i>0;i=i-4)
	{
		*address = 0x00;
		address = address + 1;
	}

	//write dma programm at c"
	address = mc ;
	for (i=0;i<DMA_CODE1_L;i++)
	{
		*address = dma_code_ns[i];
		address = address + 1;
	}

	//Modify DMA code to set up addresses
	*(mc+2) = (unsigned int)from;
	*(mc+3) = ((*(mc+3) & 0xffff)     | (((unsigned int)to & 0xffff ) << 16));
	*(mc+4) = ((*(mc+4) & 0xffff0000) | (((unsigned int)to & 0xffff0000 ) >> 16));

	dbg("Print the register value before Starting Non Secure Memory to Memory Transfers\n");
        dbg("Faltmanager reg %X\nFalt Channer reg %X\nFalt status: 0x%X\nFalt channel0 status: 0x%X\n",readl(NSDMAC2_FSRD),readl(NSDMAC2_FSRC),readl(NSDMAC2_FTRD),readl(NSDMAC2_FTCH0));
        dbg("Channel PC values 0x%X\nStatus 0x%X\n",readl(NSDMAC2_CHPC0), readl(NSDMAC2_CHST0));

	printf("Starting Non Secure Memory to Memory Transfers\n");
	// DBGINST0: DMAGO instruction on channel 0
	writel(0x02,NSDMAC2_INTEN);
	while(readl(NSDMAC2_DBGSTATUS));
	writel(0xa20000,NSDMAC2_DBGINST0);
	// DBGINST1: address of first intruction in the program
	writel(mc,NSDMAC2_DBGINST1);
	// Enables the interrupt 1
	// DBGCMD: instructs the DMA to execute the instruction
	writel(0x00,NSDMAC2_DBGCMD);
	/* Generate Non-Secure Mem-Mem request for DMA2  */
	writel(0x1000,SHIKHARA_SYS_CTRL_DMAC_CONFIG_REG);
	// wait for interrupt
	while (errors < 1000)
	{   st=readl(NSDMAC2_INTSTATUS)|| readl(NSDMAC2_ES);
		if(st) // Poll for interrupts
			break;
		errors +=1;
	}
	dbg("Print the register value after Non Secure Memory to Memory Transfers\n");
	dbg("Faltmanager reg %X\nFalt Channer reg %X\nFalt status: 0x%X\nFalt channel0 status: 0x%X\n",readl(NSDMAC2_FSRD),readl(NSDMAC2_FSRC),readl(NSDMAC2_FTRD),readl(NSDMAC2_FTCH0));
	dbg("Channel PC values 0x%X\nStatus 0x%X\n",readl(NSDMAC2_CHPC0), readl(NSDMAC2_CHST0));
	dbg("Interrupt Status : 0x%X  and error %d\n",st,errors);
	if(!st)
	{
		printf("FAILED: Non-Secure DMA  interrupt test\n");
	}
	else
	{
		printf("PASSED: Non-Secure DMA interrupt test\n");
	}

	errors = 0;
	//Clear interrupt
	writel(0x02,NSDMAC2_INTCLR);
	//Test memory
	data = 0x12345678;
	address = to;

	for (i=BUF_LEN;i>0;i=i-4)
	{
		if ((*address) != (data))
		{
			pass = FALSE;
			printf("ERROR: Addres 0x%p ,Should be :0x%x Is: 0x%x \n", address,data,*address);
			errors += 1;
			if(errors >= 10)
				break;
		}

		address = address + 1;
	}

	// Disables the interrupt
	writel(0x00,NSDMAC2_INTEN);
	if (pass)
		printf("PASSED: Non-Secure M2M DMA transfer test\n\n");
	else 
		printf("FAILED: Non-Secure M2M DMA transfer test\n\n");

	
	return pass;
}

int dmatest_sram ()
{
	unsigned int i,st;
	unsigned int data, errors = 0;
	volatile unsigned int * address;
	#if 0
	volatile unsigned int *from = (unsigned int *)malloc(BUF_LEN);
	volatile unsigned int *to = (unsigned int *)CONFIG_SMC_SRAM_BASE ;
	volatile unsigned int *mc = (unsigned int *)malloc(MC_CODE_LEN);
	#endif
	volatile unsigned int *from = (unsigned int *)0x10;
	volatile unsigned int *to = (unsigned int *)0xc4000000;
	volatile unsigned int *mc = (unsigned int *)0x4000;
	int pass = TRUE;

	writel(0x00,SHIKHARA_SYS_CTRL_DMAC_CONFIG_REG);
	udelay(10);
	/*Release reset for DMAC*/
	writel(0x0,SHIKHARA_SYS_CTRL_DMAC_CONFIG_RESET);

	printf("DMA Test: Perform  SRAM Memory to DDR Memory Test from address 0x%X and to 0x%X \n",from,to);
	//Fill memory with test pattern
	data = 0x12345678;
	address = from;
	for (i=BUF_LEN;i>0;i=i-4)
	{
		*address = data;
		address = address + 1;
	}

	// clean destination memory
	address = to;
	for (i=BUF_LEN;i>0;i=i-4)
	{
		*address = 0x00000000;
		address = address + 1;
	}

	//write dma programm at c"
	address = mc;
	for (i=0;i<DMA_CODE1_L;i++)
	{
		*address = dma_code_s[i];
		address = address + 1;

	}

	//Modify DMA code to set up addresses
	*(mc+2) = (unsigned int)from;
	*(mc+3) = ((*(mc+3) & 0xffff)     | (((unsigned int)to & 0xffff ) << 16));
	*(mc+4) = ((*(mc+4) & 0xffff0000) | (((unsigned int)to & 0xffff0000 ) >> 16));


	udelay(400000);

	dbg("Print the register value befor Starting Secure Memory to Memory Transfers\n");
        dbg("Faltmanager reg %X\nFalt Channer reg %X\nFalt status: 0x%X\nFalt channel0 status: 0x%X\n",readl(SDMAC2_FSRD),readl(SDMAC2_FSRC),readl(SDMAC2_FTRD),readl(SDMAC2_FTCH0));
        dbg("Channel PC values 0x%X\nStatus 0x%X\n",readl(SDMAC2_CHPC0), readl(SDMAC2_CHST0));

	printf("Starting Secure Memory to Memory Transfers\n");
	// DBGINST0: DMAGO instruction on channel 0
	writel(0x01,SDMAC2_INTEN);
	while(readl(SDMAC2_DBGSTATUS));
	/*Start Channel 0 with Secure state*/
	writel(0xa00000,SDMAC2_DBGINST0);
	// DBGINST1: address of first intruction in the program
	writel(mc,SDMAC2_DBGINST1);
	// DBGCMD: instructs the DMA to execute the instruction
	writel(0x00,SDMAC2_DBGCMD);
	/* Generate Secure Mem-Mem request for DMA2 */
	writel(0x800,SHIKHARA_SYS_CTRL_DMAC_CONFIG_REG);

	// wait for interrupt
	while (errors < 10000)
	{   st=readl(SDMAC2_INTSTATUS)|| readl(SDMAC2_ES);
		if(st) // Poll for interrupts
			break;
		errors +=1;
	}

	dbg("Print the register value after Secure Memory to Memory Transfers\n");
	dbg("Faltmanager reg %X\nFalt Channer reg %X\nFalt status: 0x%X\nFalt channel0 status: 0x%X\n",readl(SDMAC2_FSRD),readl(SDMAC2_FSRC),readl(SDMAC2_FTRD),readl(SDMAC2_FTCH0));
	dbg("Channel PC values 0x%X\nStatus 0x%X\n",readl(SDMAC2_CHPC0), readl(SDMAC2_CHST0));
	dbg("Interrupt Status : 0x%X  and error %d\n",st,errors);

	//clear interrupt from DMA
	writel(0x01,SDMAC2_INTCLR);
	//Test memory
	data = 0x12345678;
	address = to;

	for (i=BUF_LEN;i>0;i=i-4)
	{
		if ((*address) != (data))
		{
			pass = FALSE;
			printf("ERROR: Addres 0x%p ,Should be :0x%x Is: 0x%x \n", address,data,*address);
			errors += 1;
			if(errors >= 10)
				break;
		}

		address = address + 1;
	}

	// Disables the interrupt
	writel(0x00,SDMAC2_INTEN);
	if (pass)
		printf("PASSED: DDR to SRAM  memory test with Secure DMA \n\n");
	else
		printf("FAILED: DDR to SRAM memory with Secure DMA \n");

	
	return pass;
}



#if SECURE_DMA
int dmatest_secure ()
{
	unsigned int i,st;
	unsigned int data, errors = 0;
	volatile unsigned int * address;
	#if 0
	volatile unsigned int *from = (unsigned int *)malloc(BUF_LEN);
	volatile unsigned int *to = (unsigned int *)malloc(BUF_LEN);
	volatile unsigned int *mc = (unsigned int *)malloc(MC_CODE_LEN);
	#endif
	volatile unsigned int *from = (unsigned int *)0x10;
	volatile unsigned int *to = (unsigned int *)0x2000;
	volatile unsigned int *mc = (unsigned int *)0x4000;
	int pass = TRUE;

	writel(0x00,SHIKHARA_SYS_CTRL_DMAC_CONFIG_REG);
	udelay(10);
	/*Release reset for DMAC*/
	writel(0x0,SHIKHARA_SYS_CTRL_DMAC_CONFIG_RESET);

	printf("DMA Test: Perform  Secure Memory to Memory Test from address 0x%X and to 0x%X \n",from,to);
	//Fill memory with test pattern
	data = 0x12345678;
	address = from;
	for (i=BUF_LEN;i>0;i=i-4)
	{
		*address = data;
		address = address + 1;
	}

	// clean destination memory
	address = to;
	for (i=BUF_LEN;i>0;i=i-4)
	{
		*address = 0x00000000;
		address = address + 1;
	}

	//write dma programm at c"
	address = mc;
	for (i=0;i<DMA_CODE1_L;i++)
	{
		*address = dma_code_s[i];
		address = address + 1;
	}

	//Modify DMA code to set up addresses
	*(mc+2) = (unsigned int)from;
	*(mc+3) = ((*(mc+3) & 0xffff)     | (((unsigned int)to & 0xffff ) << 16));
	*(mc+4) = ((*(mc+4) & 0xffff0000) | (((unsigned int)to & 0xffff0000 ) >> 16));


	udelay(400000); 

	dbg("Print the register value before starting Secure Memory to Memory Transfers\n");
        dbg("Faltmanager reg %X\nFalt Channer reg %X\nFalt status: 0x%X\nFalt channel0 status: 0x%X\n",readl(SDMAC2_FSRD),readl(SDMAC2_FSRC),readl(SDMAC2_FTRD),readl(SDMAC2_FTCH0));
        dbg("Channel PC values 0x%X\nStatus 0x%X\n",readl(SDMAC2_CHPC0), readl(SDMAC2_CHST0));
 
	printf("Starting Secure Memory to Memory Transfers\n"); 
	// DBGINST0: DMAGO instruction on channel 0
	writel(0x01,SDMAC2_INTEN);
	while(readl(SDMAC2_DBGSTATUS));
	/*Start Channel 0 with Secure state*/
	writel(0xa00000,SDMAC2_DBGINST0);
	// DBGINST1: address of first intruction in the program
	writel(mc,SDMAC2_DBGINST1);
	// DBGCMD: instructs the DMA to execute the instruction
	writel(0x00,SDMAC2_DBGCMD);
	/* Generate Secure Mem-Mem request for DMA2 */
	writel(0x800,SHIKHARA_SYS_CTRL_DMAC_CONFIG_REG);

	// wait for interrupt
	while (errors < 1000)
	{   st=readl(SDMAC2_INTSTATUS)|| readl(SDMAC2_ES);
		if(st) // Poll for interrupts
			break;
		errors +=1;
	}

	dbg("Print the register value after Secure Memory to Memory Transfers\n");
	dbg("Faltmanager reg %X\nFalt Channer reg %X\nFalt status: 0x%X\nFalt channel0 status: 0x%X\n",readl(SDMAC2_FSRD),readl(SDMAC2_FSRC),readl(SDMAC2_FTRD),readl(SDMAC2_FTCH0));
	dbg("Channel PC values 0x%X\nStatus 0x%X\n",readl(SDMAC2_CHPC0), readl(SDMAC2_CHST0));
	dbg("Interrupt Status : 0x%X  and error %d\n",st,errors);
	if(!st)
	{
		printf("FAILED: Secure DMA interrupt test\n");
	}
	else
	{
		printf("PASSED: Secure DMA interrupt test\n");
	}

	errors = 0;

	//while (*DMA_INTSTATUS && 0x1 == 0);

	//clear interrupt from DMA
	writel(0x01,SDMAC2_INTCLR);
	//Test memory
	data = 0x12345678;
	address = to;

	for (i=BUF_LEN;i>0;i=i-4)
	{
		if ((*address) != (data))
		{
			pass = FALSE;
			printf("ERROR: Addres 0x%p ,Should be :0x%x Is: 0x%x \n", address,data,*address);
			errors += 1;
			if(errors >= 10)
				break;
		}

		address = address + 1;
	}

	// Disables the interrupt
	writel(0x00,SDMAC2_INTEN);
	if (pass)
		printf("PASSED: Secure DMA transfer test\n\n");
	else 
		printf("FAILED: Secure DMA transfer test\n");

	
	return pass;
}
#endif 

int do_dmatest(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	unsigned int failtest = FALSE;

	/*Reset DMAC*/
	writel(0xF0000000,TZ );
        mdelay(100);
	writel(0xC,SHIKHARA_SYS_CTRL_DMAC_CONFIG_RESET);
	if (dmatest_ns()==TRUE)
		printf(" PASSED: Non Secure DMA test  \n");
	else
	{
		printf(" ERROR:FAILED Non Secure DMA test \n");
		failtest=TRUE;
	}
	writel(0xC0000000,TZ );
        mdelay(100);



	//Reset DMAC
	writel(0xC,SHIKHARA_SYS_CTRL_DMAC_CONFIG_RESET);
	mdelay(10);
	if (dmatest_sram()==TRUE)
		printf(" PASSED: DDR to SMC SRAM Memory test  \n");
	else
	{
		printf(" ERROR:FAILED DDR to SMC SRAM Memory test\n");
		failtest=TRUE;
	}

#if SECURE_DMA
	//        Reset DMAC
        writel(0xC,SHIKHARA_SYS_CTRL_DMAC_CONFIG_RESET);
	mdelay(10);
        if (dmatest_secure()==TRUE)
                printf(" PASSED: Secure DMAC test  \n");
        else
        {
                printf(" ERROR:FAILED  DMAC test\n");
                failtest=TRUE;
        }
#endif

	if (!failtest)
		printf("DMA Test is Successfull\n\n");  
	else
		printf("DMA Test is FAILED \n\n");
	return 0;
}

U_BOOT_CMD(
		dmamemtest, 1, 1, do_dmatest,
		"Perform Secure and Non Secure Mem2Mem Transfers\n ",
		"DMA PL330 - DMAC128 used to perform Mem2Mem Transfers\n"
	  );

