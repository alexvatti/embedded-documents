/* ------------------------------------------------------------------------ */
/* FILE:			H264Tables.cpp											*/
/* DESCRIPTION:		H.264 variable length code tables for decoder			*/
/* VERSION:			v2.00													*/
/* DATE:			29 June 2005											*/
/* MODIFIED BY:	ARC International (UK) Limited								*/
/* MODIFIED DATE:	31 March 2006											*/
/*																			*/
/*				 (c) British Telecommunications plc							*/
/*						All rights reserved 2005							*/
/*							COPYRIGHT NOTICE								*/
/*																			*/
/*	British Telecommunications plc owns the sole copyright to this			*/
/*	software. You may not (1) make a copy of this software except for the	*/
/*	purposes of maintaining a single archive copy (2) derive works			*/
/*	herefrom (3) distribute this work to others. This notice is provided	*/
/*  for information and other rights may also apply.						*/
/*																			*/
/* ------------------------------------------------------------------------ */

#include "H264Warnings.h"

#include "H264Tables.h"

/* ------------------------------------------------------------------------ */
/* NAME:		h264_inverse_quantiser_table								*/
/* DESCRIPTION:	The table used for performing the inverse quantisation.
				The value depends on the quantiser modulo 6, as well as the 
				position within the 4x4 block. As this is always used with 
				an index that is the total run, the tables are given in
				scan order rather than raster order: there is one table for
				frame scan order and one for field scan order.				*/
/* ------------------------------------------------------------------------ */

const char h264_frame_scan_inverse_quantiser_table[6][16] =
{
//    0   1   4   8   5   2   3   6   9  12  13  10   7  11  14  15   Raster index
	{10, 13, 13, 10, 16, 10, 13, 13, 13, 13, 16, 10, 16, 13, 13, 16},
	{11, 14, 14, 11, 18, 11, 14, 14, 14, 14, 18, 11, 18, 14, 14, 18},
	{13, 16, 16, 13, 20, 13, 16, 16, 16, 16, 20, 13, 20, 16, 16, 20},
	{14, 18, 18, 14, 23, 14, 18, 18, 18, 18, 23, 14, 23, 18, 18, 23},
	{16, 20, 20, 16, 25, 16, 20, 20, 20, 20, 25, 16, 25, 20, 20, 25},
	{18, 23, 23, 18, 29, 18, 23, 23, 23, 23, 29, 18, 29, 23, 23, 29}
};




/* ------------------------------------------------------------------------ */
/* NAME:		h264_quantiser_product_table								*/
/* DESCRIPTION:	The table used for performing SP decoding.
				The value is the product of a value in the quantisation 
				matrix and the corresponding value in the inverse quantisation 
				matrix. The value depends on the position within the 4x4 block. 
				As this is always used with an index that is the total run, 
				the tables are given in scan order rather than raster order: 
				there is one table for frame scan order and one for field 
				scan order.													*/
/* ------------------------------------------------------------------------ */

const int h264_frame_scan_quantiser_product_table[16] =
{
//   0   1   4   8   5   2   3   6   9  12  13  10   7  11  14  15   Raster index
   	16, 20, 20, 16, 25, 16, 20, 20, 20, 20, 25, 16, 25, 20, 20, 25
};


/* ------------------------------------------------------------------------ */
/* NAME:		h264_quantiser_chroma_mapping_table							*/
/* DESCRIPTION:	The table used to map quantiser indices to quantisers to be 
				used for chroma.
				The index is QPluma, and the table output is QPchroma, 
				thus allowing for QPluma in the range 0..51 
				and QPchroma in the range 0..39.							*/
/* ------------------------------------------------------------------------ */

const UNSIGNED_SEPTET h264_quantiser_chroma_mapping_table[52] = 
{
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 29, 30,
  31, 32, 32, 33, 34, 34, 35, 35, 36, 36, 37, 37, 37, 38, 38, 38,
  39, 39, 39, 39
};


/* ------------------------------------------------------------------------ */
/* NAME:		h264_block_offset_table										*/
/* DESCRIPTION:	The table for mapping h264_block_shape_type_t and block 
				number to index of top left 4x4 block of the block.
				This applies to macroblocks (16x16, 16x8 and 8x16) and to
				8x8 sub-partitions (8x8, 8x4, 4x8 and 4x4). 
				In the latter case to get the actual block index, the index 
				of the top left 4x4 block of the partition must be added to 
				the value from this table.									*/
/* ------------------------------------------------------------------------ */

const UNSIGNED_SEPTET h264_block_offset_table[7][4] =
{
	{ 0, 0, 0, 0},	// H264_16X16
	{ 0, 8, 0, 0},	// H264_16X8
	{ 0, 2, 0, 0},	// H264_8X16
	{ 0, 0, 0, 0},	// H264_8X8
	{ 0, 4, 0, 0},	// H264_8X4
	{ 0, 1, 0, 0},	// H264_4X8
	{ 0, 1, 4, 5}	// H264_4X4
};

/* ------------------------------------------------------------------------ */
/* NAME:		h264_block_width_table										*/
/* DESCRIPTION:	The table for mapping h264_block_shape_type_t to the 
				luminance width in pels of the sub-block.					*/
/* ------------------------------------------------------------------------ */

const UNSIGNED_SEPTET h264_block_width_table[7] =
{
	16,		// H264_16X16
	16,		// H264_16X8
	 8,		// H264_8X16
	 8,		// H264_8X8
	 8,		// H264_8X4
	 4,		// H264_4X8
	 4,		// H264_4X4
};

/* ------------------------------------------------------------------------ */
/* NAME:		h264_block_height_table										*/
/* DESCRIPTION:	The table for mapping h264_block_shape_type_t to the 
				luminance height in pels of the sub-block.					*/
/* ------------------------------------------------------------------------ */

const UNSIGNED_SEPTET h264_block_height_table[7] =
{
	16,		// H264_16X16
	 8,		// H264_16X8
	16,		// H264_8X16
	 8,		// H264_8X8
	 4,		// H264_8X4
	 8,		// H264_4X8
	 4,		// H264_4X4
};


/* ------------------------------------------------------------------------ */
/* NAME:		h264_raster_index_to_8x8_block_index_table					*/
/* DESCRIPTION:	This is used to map a raster block index (0..15) to an 8x8 
				block index (0..3).											*/
/* ------------------------------------------------------------------------ */

const UNSIGNED_SEPTET h264_raster_index_to_8x8_block_index_table[16] = 
{
	0, 0, 1, 1,
	0, 0, 1, 1,
	2, 2, 3, 3,
	2, 2, 3, 3
};

/* ------------------------------------------------------------------------ */
/* NAME:		h264_8x8_block_index_to_raster_index_table					*/
/* DESCRIPTION:	This is used to map an 8x8 block index (0..3) to a raster 
				block index (0..15), for the top left 4x4 block of the 8x8 
				block.														*/
/* ------------------------------------------------------------------------ */

const UNSIGNED_SEPTET h264_8x8_block_index_to_raster_index_table[4] =
{
	0, 2,
	8, 10
};

/* ------------------------------------------------------------------------ */
/* NAME:		h264 loop filter tables										*/
/* DESCRIPTION:	These tables are used in the loop filter.
				No loop filtering is done when index is zero. Ignoring 
				filter offsets, no filtering is done when QP < 16, so 
				the tables are only defined for QP 15..51, with all values 
				of QP < 16 using the QP 15 entries. The index into the 
				tables should therefore be related to QP-15.
				The clip table has no data for strength 0 (as not needed) 
				and none for strength 4 (as same as strength 3). 
				The index into the table should therefore be strength-1		*/
/* ------------------------------------------------------------------------ */

const unsigned char ALPHA_TABLE[37] =
{
	  0,
	  4,  4,  5,  6,  7,  8,  9, 10, 12,
	 13, 15, 17, 20, 22, 25, 28, 32, 36,
	 40, 45, 50, 56, 63, 71, 80, 90,101,
	113,127,144,162,182,203,226,255,255
};

const UNSIGNED_SEPTET BETA_TABLE[37] =
{
	  0,
	  2,  2,  2,  3,  3,  3,  3,  4,  4,
	  4,  6,  6,  7,  7,  8,  8,  9,  9,
	 10, 10, 11, 11, 12, 12, 13, 13, 14,
	 14, 15, 15, 16, 16, 17, 17, 18, 18
};

const UNSIGNED_SEPTET CLIP_TABLE[3][37] =
{
	{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 7, 8, 9,10,11,13},
	{ 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8,10,11,12,13,15,17},
	{ 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 7, 8, 9,10,11,13,14,16,18,20,23,25}
};

/* ------------------------------------------------------------------------ */
/* NAME:		h264_filter_edge_table										*/
/* DESCRIPTION:	This table gives the type of edge given the filter 
				direction and the 4x4 block number in raster scan order.
				direction 0 is horizontal filtering of vertical edges.		*/
/* ------------------------------------------------------------------------ */
#ifndef AURORA_DEBLOCK
const h264_filter_edge_type h264_filter_edge_table[2][16] =
{
	{	  H264_LEFT_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE,
		  H264_LEFT_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE,
		  H264_LEFT_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE,
		  H264_LEFT_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE	},

	{	   H264_TOP_EDGE,    H264_TOP_EDGE,    H264_TOP_EDGE,    H264_TOP_EDGE,
		H264_CENTRE_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE,
		H264_CENTRE_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE,
		H264_CENTRE_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE, H264_CENTRE_EDGE	}
};
#endif
/* ------------------------------------------------------------------------ */
/* NAME:		clip_quant_for_loop_filter_table							*/
/* DESCRIPTION:	This table is used in the loop filter to obtain indices to 
				use in the alpha beta and clip tables.
				The input is of the form average_luma/chroma_quant + 
				slice_alpha/beta -15, which is in the range -27 to 48.
				The input is clipped to the range 0 to 36.					*/
/* ------------------------------------------------------------------------ */
//const UNSIGNED_SEPTET clip_quant_for_loop_filter_table[76] =
//{
////	-27 -26 -25 -24 -23 -22 -21 -20 -19 -18 -17 -16 -15 -14
//	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
//
////	-13 -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0
//	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
//
////	  1   2   3   4   5   6   7   8   9  10  11  12  13  14
//	  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
//
////	 15  16  17  18  19  20  21  22  23  24  25  26  27  28
//	 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
//
////	 29  30  31  32  33  34  35  36  37  38  37  40  41  42
//	 29, 30, 31, 32, 33, 34, 35, 36, 36, 36, 36, 36, 36, 36,
//
////   43  44  45  46  47  48
//	 36, 36, 36, 36, 36, 36
//};

/* ------------------------------------------------------------------------ */
/* NAME:		clip_chroma_quant_table										*/
/* DESCRIPTION:	This table is used to clip the value of chroma quant 
				produced from luma_quant plus chroma offset, which is in 
				the range -12 to 63 to the range 0 to 51.					*/
/* ------------------------------------------------------------------------ */

const UNSIGNED_SEPTET clip_chroma_quant_table[76] =
{
//	-12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,

//	  2   3   4   5   6   7   8   9  10  11  12  13  14  15
	  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,

//	 16  17  18  19  20  21  22  23  24  25  26  27  28  29
	 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,

//	 30  31  32  33  34  35  36  37  38  37  40  41  42  43
	 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,

//   44  45  46  47  48  49  50  51  52  53  54  55  56  57
	 44, 45, 46, 47, 48, 49, 50, 51, 51, 51, 51, 51, 51, 51,

//   58  59  60  61  62  63
	 51, 51, 51, 51, 51, 51
};

/* ------------------------------------------------------------------------ */
/* NAME:		h264 Annex A level tables									*/
/* DESCRIPTION:	This table contains the (profile and) level limits.			*/
/* ------------------------------------------------------------------------ */

const int annex_a_level_table[NUMBER_OF_ANNEX_A_LEVELS][10] =
{
//	10*level  MB/s   MBs       DPB   Bit Rate        CPB    Vert MV    Log2  Min     Max MV
//                         (bytes)     (bit/s)    (bits)  (QP luma) Vert MV Comp  per 2 MBs
	{  10,   1485,    99,   152064,     64000,    175000,      256,       8,   2,         64},
	{  11,   3000,   396,   345600,    192000,    500000,      512,       9,   2,         64},
	{  12,   6000,   396,   912384,    384000,   1000000,      512,       9,   2,         64},
	{  13,  11880,   396,   912384,    768000,   2000000,      512,       9,   2,         64},
	{  20,  11880,   396,   912384,   2000000,   2000000,      512,       9,   2,         64},
	{  21,  19800,   792,  1824768,   4000000,   4000000,     1024,      10,   2,         64},
	{  22,  20250,  1620,  3110400,   4000000,   4000000,     1024,      10,   2,         64},
	{  30,  40500,  1620,  3110400,  10000000,  10000000,     1024,      10,   2,         32},
	{  31, 108000,  3600,  6912000,  14000000,  14000000,     2048,      11,   4,         16},
	{  32, 216000,  5120,  7864320,  20000000,  20000000,     2048,      11,   4,         16},
	{  40, 245760,  8192, 12582912,  20000000,  25000000,     2048,      11,   4,         16},
	{  41, 245760,  8192, 12582912,  50000000,  62500000,     2048,      11,   2,         16},
	{  42, 491520,  8192, 12582912,  50000000,  62500000,     2048,      11,   2,         16},
	{  50, 589824, 22080, 42301440, 135000000, 135000000,     2048,      11,   2,         16},
	{  51, 983040, 36864, 70778880, 240000000, 240000000,     2048,      11,   2,         16},
};

/* ------------------------------------------------------------------------ */
/* NAME:		Reconstruction clipping table								*/
/* DESCRIPTION:	This table is used to clip the sum of prediction and 
				residual to make a reconstructed pel. The prediction is 
				assumed to be already clipped and hence be in the range 
				0..255. The residual should be in the range -511..511 
				according to equation 8-278 of the standard. Hence the 
				input is assumed to be in the range -511..766, and is 
				clipped to 0..255.											*/
/* ------------------------------------------------------------------------ */

const unsigned char recon_clip_table[RECON_CLIP_TABLE_MAX - RECON_CLIP_TABLE_MIN + 1]=
{
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,	
	0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		0,		1,		2,		3,		4,		5,		6,		7,		8,	
	9,		10,		11,		12,		13,		14,		15,		16,		17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,	
	29,		30,		31,		32,		33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,	
	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,		65,		66,		67,		68,	
	69,		70,		71,		72,		73,		74,		75,		76,		77,		78,		79,		80,		81,		82,		83,		84,		85,		86,		87,		88,	
	89,		90,		91,		92,		93,		94,		95,		96,		97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,
	109,	110,	111,	112,	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	128,
	129,	130,	131,	132,	133,	134,	135,	136,	137,	138,	139,	140,	141,	142,	143,	144,	145,	146,	147,	148,
	149,	150,	151,	152,	153,	154,	155,	156,	157,	158,	159,	160,	161,	162,	163,	164,	165,	166,	167,	168,
	169,	170,	171,	172,	173,	174,	175,	176,	177,	178,	179,	180,	181,	182,	183,	184,	185,	186,	187,	188,
	189,	190,	191,	192,	193,	194,	195,	196,	197,	198,	199,	200,	201,	202,	203,	204,	205,	206,	207,	208,
	209,	210,	211,	212,	213,	214,	215,	216,	217,	218,	219,	220,	221,	222,	223,	224,	225,	226,	227,	228,
	229,	230,	231,	232,	233,	234,	235,	236,	237,	238,	239,	240,	241,	242,	243,	244,	245,	246,	247,	248,
	249,	250,	251,	252,	253,	254,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,
	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255,	255
};

const unsigned char * recon_clip_table_centre = (recon_clip_table - RECON_CLIP_TABLE_MIN);

#ifdef _DEBUG

unsigned char recon_clip(int x)
{
	// Some non-compliant encoders may produce bitstreams that violate the range limits of
	// the standard, as detected by the above assert. In most cases, detecting the problem
	// is important, hence the assert and lookup should be used and the other commented out,
	// but in other cases, it is desirable to create an output, in which case the commented
	// code should be used instead.

	assert((x >= RECON_CLIP_TABLE_MIN) && (x <= RECON_CLIP_TABLE_MAX));
	return recon_clip_table[x-RECON_CLIP_TABLE_MIN];
/*
	if (x < 0)
	{
		return 0;
	}
	else if (x > 255)
	{
		return 255;
	}
	else
	{
		return x;
	}*/
}

#endif

/* ------------------------------------------------------------------------ */
/* NAME:		Absolute Pel Difference table								*/
/* DESCRIPTION:	This table is used to calculate the absolute value of the 
				difference of two values, in the range 0..255, such as pels.*/
/* ------------------------------------------------------------------------ */

//const unsigned char abs_pel_diff_table[ABS_PEL_DIFF_TABLE_MAX - ABS_PEL_DIFF_TABLE_MIN + 1]=
//{
//	255,	254,	253,	252,	251,	250,	249,	248,	247,	246,	245,	244,	243,	242,	241,	240,	239,	238,	237,	236,
//	235,	234,	233,	232,	231,	230,	229,	228,	227,	226,	225,	224,	223,	222,	221,	220,	219,	218,	217,	216,
//	215,	214,	213,	212,	211,	210,	209,	208,	207,	206,	205,	204,	203,	202,	201,	200,	199,	198,	197,	196,
//	195,	194,	193,	192,	191,	190,	189,	188,	187,	186,	185,	184,	183,	182,	181,	180,	179,	178,	177,	176,
//	175,	174,	173,	172,	171,	170,	169,	168,	167,	166,	165,	164,	163,	162,	161,	160,	159,	158,	157,	156,
//	155,	154,	153,	152,	151,	150,	149,	148,	147,	146,	145,	144,	143,	142,	141,	140,	139,	138,	137,	136,
//	135,	134,	133,	132,	131,	130,	129,	128,	127,	126,	125,	124,	123,	122,	121,	120,	119,	118,	117,	116,
//	115,	114,	113,	112,	111,	110,	109,	108,	107,	106,	105,	104,	103,	102,	101,	100,	99,		98,		97,		96,	
//	95,		94,		93,		92,		91,		90,		89,		88,		87,		86,		85,		84,		83,		82,		81,		80,		79,		78,		77,		76,	
//	75,		74,		73,		72,		71,		70,		69,		68,		67,		66,		65,		64,		63,		62,		61,		60,		59,		58,		57,		56,	
//	55,		54,		53,		52,		51,		50,		49,		48,		47,		46,		45,		44,		43,		42,		41,		40,		39,		38,		37,		36,	
//	35,		34,		33,		32,		31,		30,		29,		28,		27,		26,		25,		24,		23,		22,		21,		20,		19,		18,		17,		16,	
//	15,		14,		13,		12,		11,		10,		9,		8,		7,		6,		5,		4,		3,		2,		1,		0,		1,		2,		3,		4,	
//	5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,		17,		18,		19,		20,		21,		22,		23,		24,	
//	25,		26,		27,		28,		29,		30,		31,		32,		33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,	
//	45,		46,		47,		48,		49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,	
//	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		78,		79,		80,		81,		82,		83,		84,	
//	85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,		97,		98,		99,		100,	101,	102,	103,	104,
//	105,	106,	107,	108,	109,	110,	111,	112,	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,
//	125,	126,	127,	128,	129,	130,	131,	132,	133,	134,	135,	136,	137,	138,	139,	140,	141,	142,	143,	144,
//	145,	146,	147,	148,	149,	150,	151,	152,	153,	154,	155,	156,	157,	158,	159,	160,	161,	162,	163,	164,
//	165,	166,	167,	168,	169,	170,	171,	172,	173,	174,	175,	176,	177,	178,	179,	180,	181,	182,	183,	184,
//	185,	186,	187,	188,	189,	190,	191,	192,	193,	194,	195,	196,	197,	198,	199,	200,	201,	202,	203,	204,
//	205,	206,	207,	208,	209,	210,	211,	212,	213,	214,	215,	216,	217,	218,	219,	220,	221,	222,	223,	224,
//	225,	226,	227,	228,	229,	230,	231,	232,	233,	234,	235,	236,	237,	238,	239,	240,	241,	242,	243,	244,
//	245,	246,	247,	248,	249,	250,	251,	252,	253,	254,	255
//};

//#ifdef _DEBUG
//
//unsigned char abs_pel_diff(int x)
//{
//	assert((x >= ABS_PEL_DIFF_TABLE_MIN) && (x <= ABS_PEL_DIFF_TABLE_MAX));
//
//	return abs_pel_diff_table[x-ABS_PEL_DIFF_TABLE_MIN];
//}
//
//#endif


/* ------------------------------------------------------------------------ */
/* END OF FILE																*/
/* ------------------------------------------------------------------------ */
