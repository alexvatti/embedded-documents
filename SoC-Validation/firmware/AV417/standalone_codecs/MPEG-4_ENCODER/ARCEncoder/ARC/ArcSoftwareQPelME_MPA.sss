// CONFIDENTIAL AND PROPRIETARY INFORMATION                        //
// Copyright 2007 ARC International (Unpublished)                  //
// All Rights Reserved.                                            //
//                                                                 //
// This document, material and/or software contains confidential   //
// and proprietary information of ARC International and is         //
// protected by copyright, trade secret and other state, federal,  //
// and international laws, and may be embodied in patents issued   //
// or pending.  Its receipt or possession does not convey any      //
// rights to use, reproduce, disclose its contents, or to          //
// manufacture, or sell anything it may describe.  Reverse         //
// engineering is prohibited, and reproduction, disclosure or use  //
// without specific written authorization of ARC International is  //
// strictly forbidden.  ARC and the ARC logotype are trademarks of //
// ARC International.                                              //


    showstalls
    setw                120
    metaware
    macrotable          Software_QPelME,8
    strict

    include "../ARC/SIMD_ABI.ii"

#include "ArcMPC.h"
#include "ArcSDMTables.h"
#include "ArcChannelRoutines.h"
#include "ArcMacroRecordSettings.h"
#include "ArcSoftwareME_MPA.h"

import Software_ME, 1, endofIter
import Software_ME, 2, initRDvals
//----------------------------------------------------------------------------------------------------
// Is Macro
// Init members of MPC circular buffer
// Sets CirBuf
// Sets FixBuf
// Sets CirLeft
p16 PredX = i0, PredY = i1
p16 VecX = i2, VecY = i3
p16 PatternMatch = i6
p16 lambda   = i7
p16 BestCost = i8
p16 lastX = i10, lastY = i11
p16 StepMult = i12
vec16 result  = vr14
vec16 PartRes

p16 CirPtr, RefPtr

//  function QuartPel_half_half
//  function to search for 1/4 motion offsets starting at point which is at 1/2 pel unit 
//  in horiz and in vert direction
func.s QuartPelME_half_half

//p16  CirPtr, RefPtr



p16 row
vec16 cur0, cur1

begin


vec16 right0, right1, right2, right3, right4
vec16 left0, left1, left2, left3, left4
vec16 zero0, zero1, zero2, zero3
vec16 inputleft1, inputleft2, inputright1, inputright2

regmap

     
vim CirPtr, CirBuf, MPO_PixelCoeffBuffer + PCB_CURRENT_Y   


///*  The 8 points in this last step are done in this pattern :       */
///*                                                                  */
///*      res2 (-.25,-.25)   res1 (0,-.25)    res0 (.25,-.25)         */
///*      res5 (-.25,   0)                    res3 (.25,   0)         */
///*      res8 (-.25, .25)   res7 (0, .25)    res6 (.25, .25)         */
///*                                                                  */
// load 12 rows of current data (not enough vecs for all 16) 
// last 4 rows will be loaded into cur0 - cur4, done like this to avoid re-shifting reference data that
// is used for several offset calculations


// load rows of 32 pels from reference
// RefPtr set in calling function

vld128 inputright2, [RefPtr, 16]
vld128 inputleft2, [RefPtr, 0]
vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE    // increment to next line
// setup loop counter
// 16 rows total, 2 rows per loop
vmovw               'row, 8-1
vmrb   zero2, inputright2, inputleft2   
vld128 inputright1, [RefPtr, 16]
vld128 inputleft1,  [RefPtr, 0]
vspib left2,  inputleft2, zero2  // find 3/4 pos
vspib right2, zero2, inputleft2  // find 1/4 pos
vavrb zero2,  zero2, inputleft2  // find 1/2 pos

// from here loop

label SubHHLoop

// load next row
vld128  cur0, [CirPtr, 0]

vmrb   zero1, inputright1, inputleft1

vim     CirPtr, CirPtr, PCB_CURRENT_STRIDE // increment ready for next read
vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE
vspib  left1, inputleft1, zero1  // find 3/4 pos
vspib right1, zero1, inputleft1  // find 1/4 pos
vavrb zero1,  zero1, inputleft1  // find 1/2 pos

vavrb left4, left1, left2    // (1/4, 1/2)
vavrb right4, right1, right2 // (3/4, 1/2)

// combine vertically  3:1
vspib left0,  left2,  left1  // (1/4, 1/4)
vspib zero0, zero2, zero1    // (1/2, 1/4)
vspib right0, right2, right1 // (3/4, 1/4)

// combine vertically 1:3
vspib left3,  left1,  left2 // (1/4, 3/4)
vspib zero3,  zero1,  zero2  // (1/2, 3/4)
vspib right3, right1, right2 // (3/4, 3/4)
// accumulate SAD
vsadbw.1 PartRes, cur0, left0
vsadbw.2 PartRes, cur0, zero0
vsadbw.4 PartRes, cur0, right0
vsadbw.8 PartRes, cur0, left4
vsadbw.16 PartRes, cur0, right4
// accumulate SAD
vld128 inputright2, [RefPtr, 16]
vld128 inputleft2,  [RefPtr, 0]

vsadbw.32 PartRes, cur0, left3
vsadbw.64 PartRes, cur0, zero3
vsadbw.128 PartRes, cur0, right3
// end of first test row for all 8 positions


vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE

vmrb   zero2, inputright2, inputleft2
vaddw.255 result, result, PartRes
// load next row
vld128  cur1, [CirPtr, 0]
vim     CirPtr, CirPtr, PCB_CURRENT_STRIDE
vspib left2,   inputleft2, zero2  // find 3/4 pos
vspib right2,  zero2, inputleft2  // find 1/4 pos
vavrb zero2,   zero2, inputleft2  // find 1/2 pos

vavrb left4, left1, left2    // (1/4, 1/2)
vavrb right4, right1, right2 // (3/4, 1/2)

// combine vertically  3:1
vspib left0,  left1,  left2  // (1/4, 1/4)
vspib zero0,  zero1,  zero2    // (1/2, 1/4)
vspib right0, right1, right2 // (3/4, 1/4)
// combine vertically 1:3
vspib left3,  left2,  left1  // (1/4, 3/4)
vspib zero3,  zero2,  zero1  // (1/2, 3/4)
vspib right3, right2, right1 // (3/4, 3/4)
// accumulate SAD
vsadbw.1 PartRes, cur1, left0
vsadbw.2 PartRes, cur1, zero0
vsadbw.4 PartRes, cur1, right0

vsadbw.8 PartRes, cur1, left4
vsadbw.16 PartRes, cur1, right4
// accumulate SAD
vsadbw.32 PartRes, cur1, left3
vsadbw.64 PartRes, cur1, zero3
vsadbw.128 PartRes, cur1, right3
// end of second test row for all 8 positions

// decrement and loop
vjd.row             row, .SubHHLoop
// to here loop


~vld128 inputright1, [RefPtr, 16]
~vld128 inputleft1,  [RefPtr, 0]
~vaddw.255 result, result, PartRes


    // return to caller
vjb                 VSTACK, 0
~vnop
~vnop
~vnop  
end

endfunc
//  function QuartPel_half_int
//  function to search for 1/4 motion offsets starting at point which is at integer pel unit 
//  in vert direction and 1/2 pel in horizontal direction
func.s QuartPelME_half_int


//p16  CirPtr, RefPtr

p16 row

begin


vec16 cur0, cur1
vec16 right0, right1, right2, right3, right4
vec16 left0, left1, left2, left3, left4
vec16 zero0, zero1, zero2, zero3
vec16 inputleft1, inputleft2, inputright1, inputright2

regmap

     
//vmovw        'RefPtr,SDM_ME_REFERENCE_ARRAY
    // rowLoop start
vim CirPtr, CirBuf, MPO_PixelCoeffBuffer + PCB_CURRENT_Y   


///*  The 8 points in this last step are done in this pattern :       */
///*                                                                  */
///*      res2 (-.25,-.25)   res1 (0,-.25)    res0 (.25,-.25)         */
///*      res5 (-.25,   0)                    res3 (.25,   0)         */
///*      res8 (-.25, .25)   res7 (0, .25)    res6 (.25, .25)         */
///*                                                                  */
// load 12 rows of current data (not enough vecs for all 16) 
// last 4 rows will be loaded into cur0 - cur4, done like this to avoid re-shifting reference data that
// is used for several offset calculations

vld128 inputright2, [RefPtr, 16]
vld128 inputleft2,  [RefPtr, 0]
// setup loop counter
// 16 rows total, 2 rows per loop    

vld128 inputright1, [RefPtr, 48]
vld128 inputleft1,  [RefPtr, 32]
vmovw               'row, 8-1
vmrb   zero2, inputright2, inputleft2
//left2, zero2, right2 now are at (1/4,0), (1/2,0) and (3/4, 0)



vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE*2


vmrb   zero1, inputright1, inputleft1
vspib left2,  inputleft2, zero2  // find 3/4 pos
vspib right2, zero2, inputleft2  // find 1/4 pos

vspib left1,  inputleft1, zero1  // find 3/4 pos
vspib right1, zero1, inputleft1  // find 1/4 pos
vavrb zero1,  zero1, inputleft1  // find 1/2 pos    
// left1, zero1, right1 now are at (1/4,1), (1/2,1)  and (3/4,1)
vavrb zero2,  zero2, inputleft2  // find 1/2 pos

label SubHILoop





vld128 inputright2, [RefPtr, 16]
vld128 inputleft2,  [RefPtr, 0]

vspib left0, left1, left2    // (1/4, 3/4)
vspib zero0, zero1, zero2    // (1/2, 3/4)
vspib right0, right1, right2 // (3/4, 3/4)

// combine vertically 1:3


vmrb   zero2, inputright2, inputleft2

// load next row
vld128  cur0, [CirPtr, 0]
vim     CirPtr, CirPtr, PCB_CURRENT_STRIDE // increment ready for next read

vspib left2,  inputleft2, zero2  // find 3/4 pos
vspib right2, zero2, inputleft2  // find 1/4 pos
vavrb zero2,  zero2, inputleft2  // find 1/2 pos

// accumulate SAD
vsadbw.1 PartRes,  cur0,  left0
vsadbw.2 PartRes,  cur0,  zero0
vsadbw.4 PartRes,  cur0,  right0

// combine vertically  3:1
vspib left3,  left1,  left2    // (1/4, 1/4)
vspib zero3,  zero1,  zero2    // (1/2, 1/4)
vspib right3, right1, right2   // (3/4, 1/4)
// accumulate SAD


vsadbw.8 PartRes,  cur0,  left1
vsadbw.16 PartRes, cur0,  right1
vsadbw.32 PartRes, cur0,  left3
vsadbw.64 PartRes, cur0,  zero3
vsadbw.128 PartRes, cur0, right3

vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE
vld128  cur1, [CirPtr, 0] // ready for next row
vaddw.255 result, result, PartRes

// end of first test row for all 8 positions

vld128 inputright1, [RefPtr, 16]
vld128 inputleft1, [RefPtr, 0]
// combine vertically  3:1
vspib left0,  left2,  left1    // (1/4, 1/4)
vspib zero0,  zero2,  zero1    // (1/2, 1/4)
vspib right0, right2, right1   // (3/4, 1/4)

vmrb   zero1, inputright1, inputleft1


vim     CirPtr, CirPtr, PCB_CURRENT_STRIDE // increment ready for next read

vspib left1,  inputleft1, zero1  // find 3/4 pos
vspib right1, zero1, inputleft1  // find 1/4 pos
vavrb zero1,  zero1, inputleft1  // find 1/2 pos


// accumulate SAD
vsadbw.1 PartRes, cur1, left0
vsadbw.2 PartRes, cur1, zero0
vsadbw.4 PartRes, cur1, right0

// combine vertically  3:1
vspib right3, right2, right1 // (3/4, 1/4)
vspib left3,  left2,  left1  // (1/4, 1/4)
vspib zero3, zero2, zero1    // (1/2, 1/4)
// accumulate SAD
vsadbw.8  PartRes, cur1, left2
vsadbw.16 PartRes, cur1, right2
// accumulate SAD
vsadbw.32 PartRes, cur1, left3
vsadbw.64 PartRes, cur1, zero3
vsadbw.128 PartRes, cur1, right3
// end of second test row for all 8 positions


// decrement and loop
vjd.row             row, .SubHILoop

~vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE
~vaddw.255 result, result, PartRes
~vnop


    // return to caller
vjb                 VSTACK, 0
~vnop
~vnop
~vnop 
end

endfunc


//  function QuartPel_int_half
//  function to search for 1/4 motion offsets starting at point which is at half pel unit 
//  in vert direction and integer pel in horizontal direction
func.s QuartPelME_int_half


//p16  CirPtr, RefPtr

p16 row

begin


vec16 cur0, cur1
vec16 right0, right1, right2, right3, right4
vec16 left0, left1, left2, left3, left4
vec16 zero0, zero1, zero2, zero3
vec16 inputleft1, inputright1, inputleft2, inputright2
regmap

    


///*  The 8 points in this last step are done in this pattern :       */
///*                                                                  */
///*      res2 (-.25,-.25)   res1 (0,-.25)    res0 (.25,-.25)         */
///*      res5 (-.25,   0)                    res3 (.25,   0)         */
///*      res8 (-.25, .25)   res7 (0, .25)    res6 (.25, .25)         */
///*                                                                  */
// load 12 rows of current data (not enough vecs for all 16) 
// last 4 rows will be loaded into cur0 - cur4, done like this to avoid re-shifting reference data that
// is used for several offset calculations

vld128 inputright2, [RefPtr, 16]
vld128 inputleft2, [RefPtr, 0]

vim CirPtr, CirBuf, MPO_PixelCoeffBuffer + PCB_CURRENT_Y   
vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE
vmrb   zero2,  inputright2, inputleft2
vmr1w  right2, inputright2, inputleft2
// setup loop counter
// 16 rows total, 2 rows per loop    
vmovw               'row, 8-1
vspib left2,  zero2, inputleft2  // find 1/4 pos
vspib right2, zero2, right2  // find 3/4 pos

label SubIHLoop

// load next row

vld128 inputright1, [RefPtr, 16]
vld128 inputleft1, [RefPtr, 0]
vld128  cur0, [CirPtr, 0]
vim     CirPtr, CirPtr, PCB_CURRENT_STRIDE // increment ready for next read

vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE

vmrb   zero1,  inputright1, inputleft1
vmr1w  right1, inputright1, inputleft1


vld128 inputright2, [RefPtr, 16]
vld128 inputleft2, [RefPtr, 0]

vspib zero0, zero2, zero1    // (  0, 1/4)

vspib right1, zero1, right1  // find 1/4 pos
vspib left1,  zero1, inputleft1  // find 3/4 pos   


vspib zero3, zero1, zero2    // (  0, 3/4)

vspib right0, right2, right1 // (3/4, 1/4)
vspib left0, left2, left1    // (1/4, 1/4)
vavrb right4,  right1, right2  // find 1/2 pos
vavrb left4,  left1, left2     // find 1/2 pos
vspib right3, right1, right2 // (3/4, 3/4)
vspib left3, left1, left2    // (1/4, 3/4)


vsadbw.1 PartRes, cur0,   left0
vsadbw.2 PartRes, cur0,   zero0
vsadbw.4 PartRes, cur0,   right0
vsadbw.8 PartRes, cur0,   left4
vsadbw.16 PartRes, cur0,  right4
vsadbw.32 PartRes, cur0,  left3
vsadbw.64 PartRes, cur0,  zero3
vsadbw.128 PartRes, cur0, right3
// end of first test line

vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE

vld128  cur1, [CirPtr, 0]

vmrb   zero2,  inputright2, inputleft2
vmr1w  right2, inputright2, inputleft2


vaddw.255 result, result, PartRes

vim     CirPtr, CirPtr, PCB_CURRENT_STRIDE // increment ready for next read

vspib  right2, zero2, right2  // find 1/4 pos
vspib  left2,  zero2, inputleft2  // find 3/4 pos

vspib zero0, zero1, zero2    // (  0, 1/4)
vspib right0, right1, right2 // (3/4, 1/4)
vspib left0, left1, left2    // (1/4, 1/4)

vavrb right4,  right2, right1  // find 1/2 pos
vavrb left4,  left2, left1     // find 1/2 pos

vspib right3, right2, right1 // (3/4, 3/4)
vspib left3, left2, left1    // (1/4, 3/4)
vspib zero3, zero2, zero1    // (  0, 3/4)


vsadbw.1 PartRes, cur1,  left0
vsadbw.2 PartRes, cur1,  zero0
vsadbw.4 PartRes, cur1,  right0
vsadbw.8 PartRes,  cur1, left4
vsadbw.16 PartRes, cur1, right4
vsadbw.32 PartRes, cur1, left3
vsadbw.64 PartRes, cur1, zero3
// end of second test line

// decrement and loop
vjd.row             row, .SubIHLoop
~vsadbw.128 PartRes, cur1, right3
~vnop
~vaddw.255 result, result, PartRes

  
    // return to caller
vjb                 VSTACK, 0
~vnop
~vnop
~vnop 
end

endfunc


//  function QuartPel_int_int
//  function to search for 1/4 motion offsets starting at point which is at integer pel unit 
//  in vert direction and integer pel in horizontal direction
func.s QuartPelME_int_int


//p16  CirPtr, RefPtr

p16 row

begin


vec16 cur0,cur1
vec16 right0, right1, right2, right3, right4, right5
vec16 left0, left1, left2,left3, left4, left5
vec16 zero0, zero1, zero2, zero3, zero4, zero5
vec16 inputleft1, inputright1
vec16 inputleft2, inputright2

regmap

     
//vmovw        'RefPtr,SDM_ME_REFERENCE_ARRAY
    // rowLoop start
vim CirPtr, CirBuf, MPO_PixelCoeffBuffer + PCB_CURRENT_Y   


///*  The 8 points in this last step are done in this pattern :       */
///*                                                                  */
///*      res2 (-.25,-.25)   res1 (0,-.25)    res0 (.25,-.25)         */
///*      res5 (-.25,   0)                    res3 (.25,   0)         */
///*      res8 (-.25, .25)   res7 (0, .25)    res6 (.25, .25)         */
///*                                                                  */


vld128 inputright2, [RefPtr, 16]
vld128 inputleft2, [RefPtr, 0]

vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE
// load next row
vld128  cur0, [CirPtr, 0]

vmrb   zero2,  inputright2, inputleft2
vmr1w  right2, inputright2, inputleft2

vld128 inputright1, [RefPtr, 16]
vld128 inputleft1, [RefPtr, 0]

vspib right2, zero2, right2  // find 1/4 pos
vspib left2,  zero2, inputleft2   // find -1/4 pos
    

vim     CirPtr, CirPtr, PCB_CURRENT_STRIDE // increment ready for next read

vmrb   zero1,  inputright1, inputleft1
vmr1w  right1, inputright1, inputleft1
 // setup loop counter
// 16 rows total, 2 rows per loop
vmovw               'row, 8-1

vspib left1,  zero1, inputleft1   // find -1/4 pos  
vspib right1, zero1, right1  // find 1/4 pos   
   
label SubIILoop // loop starts here 



vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE

vspib left0, left1, left2    // (1/4, 1/4) - no longer need to save the 2's
vspib zero0, zero1, zero2    // (1/2, 1/4)
vspib right0, right1, right2 // (3/4, 1/4)

vld128 inputright2, [RefPtr, 16]
vld128 inputleft2, [RefPtr, 0]


vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE
vld128  cur1, [CirPtr, 0]

vim     CirPtr, CirPtr, PCB_CURRENT_STRIDE // increment ready for next read

vmrb   zero2,  inputright2, inputleft2
vmr1w  right2, inputright2, inputleft2


vld128 inputleft1, [RefPtr, 0]
vld128 inputright1, [RefPtr, 16]

vspib right2, zero2, right2  // find 1/4 pos
vspib left2,  zero2, inputleft2  // find 3/4 pos


vsadbw.1 PartRes, cur0, left0

vspib zero3, zero1, zero2    // (1/4, 3/4)
vspib right3, right1, right2 // (3/4, 3/4)
vspib left3, left1, left2    // (1/4, 3/4)

vsadbw.2 PartRes, cur0, zero0
vsadbw.4 PartRes, cur0, right0
vsadbw.8  PartRes, cur0, left1
vsadbw.16 PartRes, cur0, right1
vsadbw.32 PartRes, cur0, left3
vsadbw.64 PartRes, cur0, zero3
vsadbw.128 PartRes, cur0, right3

vspib zero4,  zero2,  zero1    // (1/4, 3/4)
vspib left4,  left2,  left1    // (1/4, 3/4)
vspib right4, right2, right1 // (3/4, 3/4)

vmrb   zero1, inputright1, inputleft1
vmr1w  right1, inputright1, inputleft1

vaddw.255 result, result, PartRes


// end of first test line

vspib right1, zero1, right1  // find 1/4 pos
vspib left1,  zero1, inputleft1  // find 3/4 pos 


vspib zero5,  zero2,  zero1    // (1/4, 3/4)
vspib right5, right2, right1 // (3/4, 3/4)
vspib left5,  left2,  left1    // (1/4, 3/4)

vsadbw.1 PartRes, cur1, left4
vsadbw.2 PartRes, cur1, zero4
vsadbw.4 PartRes, cur1, right4
vsadbw.8 PartRes, cur1, left2
vsadbw.16 PartRes, cur1, right2
vsadbw.32 PartRes, cur1, left5
vsadbw.64 PartRes, cur1, zero5
vsadbw.128 PartRes, cur1, right5
// end of second test line


// decrement and loop
vjd.row             row, .SubIILoop

// now find the minimum
// since it's difficult to find argmin(vector)
// it might be just as easy to test each of the 8 positions sequentially
// load next row
~vld128  cur0, [CirPtr, 0]
~vim     CirPtr, CirPtr, PCB_CURRENT_STRIDE // increment ready for next read
~vaddw.255 result, result, PartRes

    // return to caller
vjb                 VSTACK, 0
~vnop
~vnop
~vnop 
end

endfunc


func.f QuarterPelSearch


begin
p16 lastX = i10, lastY = i11
p16 switch = i15
s16 tempX: lastX
s16 tempY: lastY
s16 tempRef: RefPtr
vec16 vecadd

// firstly move reference data if required - only needed if lastX=2 
// if lastY == 2, then we simply record that the RefPtr needs to be offset
// and use that in the next step, without having to reposition
begin
vec16 ref0, ref1, ref2, ref3
p16 offsetY
regmap
vim offsetY, lastY, -1  // now -3, -1 or 1
vmaxw 'offsetY, 'offsetY, 0  // 0, 0, or 1
vmulw 'offsetY, 'offsetY, ME_REFERENCE_ARRAY_STRIDE // gives 1 2 or 3 lines

vim   RefPtr, offsetY, SDM_ME_REFERENCE_ARRAY // source ptr
vmovw 'CirPtr, SDM_ME_REFERENCE_ARRAY
vim switch, lastX, -2


vjp.switch  .EndQPelReposition
~vnop
~vnop
~vnop

vmovw 'StepMult, (18/2)-1
label ShiftRightQ1new


vld128  ref0, [RefPtr,  0]
vld128  ref1, [RefPtr, 16]
vld128  ref2, [RefPtr, 32]
vld128  ref3, [RefPtr, 48]

vim     RefPtr, RefPtr, ME_REFERENCE_ARRAY_STRIDE*2
vmrb    ref0, ref1,ref0          // shift by 1 pixels
vsr8    ref1, ref1, 1            // shift by 1 pixels
vmrb    ref2, ref3,ref2          // shift by 1 pixels
vsr8    ref3, ref3, 1            // shift by 1 pixels

vst128  ref0, [CirPtr, 0]
vst128  ref1, [CirPtr,16]

vjd.StepMult     StepMult, .ShiftRightQ1new
~vst128  ref2, [CirPtr, 32]
~vst128  ref3, [CirPtr, 48]
~vim CirPtr, CirPtr, ME_REFERENCE_ARRAY_STRIDE*2


vmovw   'RefPtr, SDM_ME_REFERENCE_ARRAY // reset ready for qpel functions

label EndQPelReposition


end
vmovw 'StepMult,  1  // multiplier for RD costs 

vjl     VSTACK, .initRDvals

~vmovw'0      vecadd, .QuartPelME_int_int
~vmovw'1      vecadd, .QuartPelME_half_int
~vmovw'2      vecadd, .QuartPelME_int_half
vmovw'3      vecadd, .QuartPelME_half_half



// last Y was 2 then need to start a line lower

// now need to find out which function to call for qpel
// it depends on whether each component is integer or half pixel so far
vabsw   'lastX'lastY,'VecX'VecY
vand    'lastX'lastY,'lastX'lastY, 2    // 2nd bit set indicates 1/2 pel chosen
vasrw   'lastX,'lastX, 1                // shift down X to 1 or 0
move16   tempX, lastY
vaddw   'lastX, 'lastX, 'tempX          // add Y to X
//move16   switch, lastX
//lastX now has value of 0, to 3 depending on which half pel vals are used
// now use lastX to decide which subroutine to use.


vjlt         VSTACK, vecadd, lastX // jump to the right bit of code
~vnop
~vnop
~vnop
vjl          VSTACK, .endofIter

~vnop
~vnop
~vnop 

end
endfunc
