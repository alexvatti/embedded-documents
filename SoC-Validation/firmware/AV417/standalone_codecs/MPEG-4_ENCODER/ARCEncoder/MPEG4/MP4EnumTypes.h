/* CONFIDENTIAL AND PROPRIETARY INFORMATION                        */
/* Copyright 2007 ARC International (Unpublished)                  */
/* All Rights Reserved.                                            */
/*                                                                 */
/* This document, material and/or software contains confidential   */
/* and proprietary information of ARC International and is         */
/* protected by copyright, trade secret and other state, federal,  */
/* and international laws, and may be embodied in patents issued   */
/* or pending.  Its receipt or possession does not convey any      */
/* rights to use, reproduce, disclose its contents, or to          */
/* manufacture, or sell anything it may describe.  Reverse         */
/* engineering is prohibited, and reproduction, disclosure or use  */
/* without specific written authorization of ARC International is  */
/* strictly forbidden.  ARC and the ARC logotype are trademarks of */
/* ARC International.                                              */
/* May contain code (c) British Telecommunications plc 2005        */

#ifndef	MP4_ENUM_TYPES_H
#define	MP4_ENUM_TYPES_H

#ifdef __SYMBIAN32__
	#include "stdafx.h"
#else
#ifndef	_WIN32_WCE
	#include <assert.h>
#endif
	#include <limits.h>
#endif

#ifndef __cplusplus
#define bool int
#define false 0
#define true 1
#endif 

// UNSIGNED_SEPTET is used for unsigned 7 bit values. It is defined as either
// a signed or unsigned char depending on the target processor. Signed char
// appears faster on the Pentium as there is a "load byte with sign extension"
// instruction. Unsigned char appears faster on the ARM as "load" compiles to
// less instructions than when signed.
#ifdef __arm
#define UNSIGNED_SEPTET unsigned char
#else
#define UNSIGNED_SEPTET signed char
#endif

#define PIXEL unsigned char

#define CODED_BYTE unsigned char

#define WORKING_ARRAY_SIZE 21
#define NUMBER_OF_VECTORS_PER_MACROBLOCK		 16
#define NUMBER_OF_Y_PELS_PER_BLOCK				256
#define NUMBER_OF_U_PELS_PER_BLOCK				 64
#define NUMBER_OF_V_PELS_PER_BLOCK				 64

#define NUMBER_OF_LUMA_EIGHT_BY_EIGHT_BLOCKS	  4

#define NUMBER_OF_LUMA_FOUR_BY_FOUR_BLOCKS		 16
#define NUMBER_OF_CHROMA_FOUR_BY_FOUR_BLOCKS	  4

#define MINIMUM_QUANTISER_INDEX					 1
#define MAXIMUM_QUANTISER_INDEX					 31

#define MAXIMUM_NUMBER_OF_STORED_FRAMES			 2


#define DIAMOND_SEARCH_FULL_PEL		2300	// THREE_STEP_SEARCH_FULL_PEL
#define DIAMOND_SEARCH_SUB_PEL		2301	// THREE_STEP_SEARCH_HALF_PEL
#define FULL_SEARCH_FULL_PEL		2302	// FULL_SEARCH_FULL_PEL
#define FULL_SEARCH_SUB_PEL			2303	// FULL_SEARCH_HALF_PEL

#define NOT_REAL_REFERENCE_FRAME_THRESHOLD		125      // previous test was < 0, now test is > NOT_REAL_REFERENCE_FRAME_THRESHOLD
#define DIFFERENT_REFERENCE_FRAME				126      // was -2
#define REFERENCE_FRAME_NOT_AVAILABLE			127      // was -1

// The number of border pels needs to be 17 on the left and top 
// and 16 on the right and bottom - see MN working records of
// 30 October 2003. A vector of -16.5 horizontally does not lead
// to the same prediction as a vector of -16: the right most
// column of predicted pels would be different. Hence the border
//  area needs to include -16.5, and hence 17 border pels are needed.
// Note, when tested on 9 and 10 October 2003 with 16 border 
// pels all round (which is now known to be wrong), slower
// encoding is observed than when extra border pels were created.
// This is thought to have been due to 64kbyte pointer alignment

#define NUMBER_OF_LEFT_BORDER_PELS 17
#define NUMBER_OF_RIGHT_BORDER_PELS 16
#define NUMBER_OF_TOP_BORDER_PELS 17
#define NUMBER_OF_BOTTOM_BORDER_PELS 16

#ifndef ABS
#define ABS(x) (((x) < 0) ? (-(x)) : (x))
#endif

#ifndef	MAX
#define	MAX(a,b)	(((a) > (b)) ? (a) : (b))
#endif

#ifndef	MIN
#define	MIN(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#ifndef MEDIAN
#define MEDIAN(a,b,c) ( ((a) > (b)) ? ( ((c) >= (a)) ? (a) : MAX((b), (c)) ) : ( ((c) >= (b)) ? (b) : MAX((a), (c)) ) )
#endif

#ifndef CLIP
#define CLIP(low, high, x) ((x) < (low) ? (low) : ((x) > (high) ? (high) : (x)))
#endif

// QUANT_DIV calculates q/6 for 0 <= q <= 51 without a division
#ifndef	QUANT_DIV
#define	QUANT_DIV(q)	((43 * q) >> 8)
#endif

// QUANT_MOD calculates q%6 for 0 <= q <= 51 without a division using the result of QUANT_DIV
#ifndef	QUANT_MOD
#define	QUANT_MOD(q, q_div)	(q - (6 * q_div))
#endif

#ifndef MIN_POSITIVE
#define MIN_POSITIVE(a,b)  ((((a)>=0) && ((b)>=0)) ? MIN(a,b) : MAX(a,b))
#endif

/*
--------------------------------------------------------------------------------
Type definitions.
--------------------------------------------------------------------------------
*/
/*
typedef enum
{
	H264_VLD_LOST,
	H264_VLD_END_OF_NAL_UNIT,

	// Sequence Parameter Set States
	H264_VLD_PROFILE_IDC,
	H264_VLD_LEVEL_AND_FLAGS,
	H264_VLD_SEQ_PARAM_SET_ID,
	H264_VLD_LOG2_MAX_FRAME_NUMBER,
	H264_VLD_CHROMA_FORMAT_IDC,
	H264_BIT_DEPTH_LUMA_MINUS_8,
	H264_BIT_DEPTH_CHROMA_MINUS_8,
	H264_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG,
	H264_SEQ_SCALING_MATRIX_PRESENT_FLAG,
	H264_SEQ_SCALING_MATRIX_LIST,
	H264_SCALING_LIST,
	H264_VLD_PICTURE_ORDER_COUNT_TYPE,
	H264_VLD_LOG2_MAX_POC_LSB,
	H264_VLD_DELTA_PIC_ORDER_ZERO_FLAG,
	H264_VLD_OFFSET_FOR_NON_REF_PIC,
	H264_VLD_OFFSET_TOP_BOTTOM_FIELD,
	H264_VLD_NUM_REF_IN_POC_CYCLE,
	H264_VLD_OFFSET_FOR_REF_FRAME,
	H264_VLD_NUM_REF_FRAMES,
	H264_VLD_REQUIRED_FN_UPDATE_FLAG,
	H264_VLD_PICTURE_WIDTH,
	H264_VLD_PICTURE_HEIGHT,
	H264_VLD_FRAME_MBS_ONLY_FLAG,
	H264_VLD_MB_ADAPTIVE_FRAME_FIELD_FLAG,
	H264_VLD_DIRECT_8X8_INFERENCE_FLAG,
	H264_VLD_FRAME_CROPPING,
	H264_VLD_FRAME_CROP_LEFT_OFFSET,
	H264_VLD_FRAME_CROP_RIGHT_OFFSET,
	H264_VLD_FRAME_CROP_TOP_OFFSET,
	H264_VLD_FRAME_CROP_BOTTOM_OFFSET,
	H264_VLD_VUI_PARAMETERS_PRESENT_FLAG,
	H264_SECOND_CHROMA_QP_INDEX_OFFSET,
	H264_VLD_END_OF_SPS,

	// Sequence Parameter Set VUI States

	H264_VLD_VUI_ASPECT_RATIO_INFO_PRESENT,
	H264_VLD_VUI_ASPECT_RATIO_IDC,
	H264_VLD_VUI_SAR_WIDTH,
	H264_VLD_VUI_SAR_HEIGHT,
	H264_VLD_VUI_OVERSCAN_INFO_PRESENT,
	H264_VLD_VUI_OVERSCAN_FLAG,
	H264_VLD_VUI_VIDEO_SIGNAL_PRESENT,
	H264_VLD_VUI_VIDEO_FORMAT,
	H264_VLD_VUI_VIDEO_FULL_RANGE,
	H264_VLD_VUI_COLOUR_DESC_FLAG,
	H264_VLD_VUI_COLOUR_PRIMARIES,
	H264_VLD_VUI_TRANSFER_CHAR,
	H264_VLD_VUI_MATRIX_COEFFICIENTS,
	H264_VLD_VUI_CHROMA_LOC_PRESENT,
	H264_VLD_VUI_CHROMA_LOC_TOP_FIELD,
	H264_VLD_VUI_CHROMA_LOC_BOTTOM_FIELD,
	H264_VLD_VUI_TIMING_INFO_PRESENT,
	H264_VLD_VUI_NUM_UNITS_IN_TICK_MS16,
	H264_VLD_VUI_NUM_UNITS_IN_TICK_LS16,
	H264_VLD_VUI_TIME_SCALE_MS16,
	H264_VLD_VUI_TIME_SCALE_LS16,
	H264_VLD_VUI_FIXED_FRAME_RATE_FLAG,
	H264_VLD_VUI_NAL_HRD_PRESENT,
	H264_VLD_VUI_VCL_HRD_PRESENT,
	H264_VLD_VUI_LOW_DELAY_HRD_FLAG,
	H264_VLD_VUI_PIC_STRUCT_PRESENT,
	H264_VLD_VUI_BITSTREAM_RESTRICTION,
	H264_VLD_VUI_MV_OFF_PICTURE,
	H264_VLD_VUI_MAX_BYTES_PER_PIC_DENOM,
	H264_VLD_VUI_MAX_BITS_PER_MB_DENOM,
	H264_VLD_VUI_LOG2_MAX_MV_HORIZ,
	H264_VLD_VUI_LOG2_MAX_MV_VERT,
	H264_VLD_VUI_NUM_REORDER_FRAMES,
	H264_VLD_VUI_MAX_DEC_FRAME_BUFFERING,

	H264_VLD_VUI_CBP_CNT_MINUS1,
	H264_VLD_VUI_BIT_RATE_SCALE,
	H264_VLD_VUI_CBP_SIZE_SCALE,
	H264_VLD_VUI_BIT_RATE_VALUE_MINUS1,
	H264_VLD_VUI_CBP_SIZE_VALUE_MINUS1,
	H264_VLD_VUI_CBR_FLAG,
	H264_VLD_VUI_INIT_CPB_DELAY,
	H264_VLD_VUI_CPB_REMOVAL_DELAY_MINUS1,
	H264_VLD_VUI_DPB_OUTPUT_DELAY_MINUS1,
	H264_VLD_VUI_TIME_OFFSET_LENGTH,

	// Picture Parameter Set States
	H264_VLD_PICTURE_PARAMETER_SET_ID,
	H264_VLD_SEQUENCE_PARAMETER_SET_ID,
	H264_VLD_ENTROPY_CODING_MODE_FLAG,
	H264_VLD_PIC_ORDER_PRESENT_FLAG,
	H264_VLD_NUM_SLICE_GROUPS,
	H264_VLD_MB_SLICE_GROUP_MAP_TYPE,
	H264_VLD_SGT0_RUN_LENGTH,
	H264_VLD_SGT2_TOP_LEFT,
	H264_VLD_SGT2_BOTTOM_RIGHT,
	H264_VLD_SG_CHANGE_DIRECTION,
	H264_VLD_SG_CHANGE_RATE,
	H264_VLD_SGT6_PIC_SIZE_IN_MAP_UNITS,
	H264_VLD_SGT6_SLICE_GROUP_ID,
	H264_VLD_NUM_REF_IDX_L0_ACTIVE,
	H264_VLD_NUM_REF_IDX_L1_ACTIVE,
	H264_VLD_WEIGHTED_PRED_AND_BIPRED,
	H264_VLD_PIC_QP,
	H264_VLD_PIC_QS,
	H264_VLD_CHROMA_QP_OFFSET,
	H264_VLD_PPS_THREE_SINGLE_BIT_FLAGS,
	H264_TRANSFORM_8X8_MODE_FLAG,
	H264_PIC_SCALING_MATRIX_PRESENT_FLAG,
	H264_PIC_SCALING_MATRIX_LIST,
	H264_PIC_SCALING_LIST,
	H264_VLD_END_OF_PPS,

	// SEI States
	H264_VLD_SEI_PAYLOAD_TYPE,
	H264_VLD_SEI_PAYLOAD_SIZE,
	H264_VLD_SEI_PAYLOAD_DATA,
	H264_VLD_SEI_END_OF_SEI,
	H264_VLD_SEI_BYTE_ALIGNMENT,

	H264_VLD_SEI_BUFFERING_PERIOD_SPS_ID,
	H264_VLD_SEI_BUFFERING_PERIOD_NAL_INITIAL_DELAY,
	H264_VLD_SEI_BUFFERING_PERIOD_NAL_OFFSET,
	H264_VLD_SEI_BUFFERING_PERIOD_VCL_INITIAL_DELAY,
	H264_VLD_SEI_BUFFERING_PERIOD_VCL_OFFSET,

	H264_VLD_SEI_PICTURE_TIMING_CPB_REMOVAL_DELAY,
	H264_VLD_SEI_PICTURE_TIMING_DPB_REMOVAL_DELAY,
	H264_VLD_SEI_PICTURE_TIMING_PIC_STRUCT,
	H264_VLD_SEI_PICTURE_TIMING_CLOCK_TS_FLAG,
	H264_VLD_SEI_PICTURE_TIMING_FIXED_LENGTH_FIELDS,
	H264_VLD_SEI_PICTURE_TIMING_FULL_TIMESTAMP,
	H264_VLD_SEI_PICTURE_TIMING_SECONDS_FLAG,
	H264_VLD_SEI_PICTURE_TIMING_SECONDS_AND_NEXT_FLAG,
	H264_VLD_SEI_PICTURE_TIMING_MINUTES_AND_NEXT_FLAG,
	H264_VLD_SEI_PICTURE_TIMING_HOURS,
	H264_VLD_SEI_PICTURE_TIMING_TIME_OFFSET,

	H264_VLD_SEI_RECOVERY_POINT_FRAME_CNT,
	H264_VLD_SEI_RECOVERY_POINT_FLAGS,

	// Slice Header States
	H264_VLD_FIRST_MB_IN_SLICE,
	H264_VLD_SLICE_TYPE,
	H264_VLD_PICTURE_PARAMETER_SET,
	H264_VLD_FRAME_NUMBER,
	H264_VLD_FIELD_PICTURE_FLAG,
	H264_VLD_BOTTOM_FIELD_FLAG,
	H264_VLD_IDR_PICTURE_ID,
	H264_VLD_POC_LSB,
	H264_VLD_DELTA_POC_BOTTOM,
	H264_VLD_DELTA_POC_0,
	H264_VLD_DELTA_POC_1,
	H264_VLD_REDUNDANT_PICTURE_COUNT,
	H264_VLD_DIRECT_SPATIAL_FLAG,
	H264_VLD_NUM_REF_IDX_OVERRIDE,
	H264_VLD_NUM_REF_IDX_L0_MINUS1,
	H264_VLD_NUM_REF_IDX_L1_MINUS1,

	H264_VLD_REF_REORDERING_FLAG_L0,
	H264_VLD_REF_REORDERING_OF_PIC_NUMS_IDC_L0,
	H264_VLD_REF_REORDERING_NEG_DIFF_L0,
	H264_VLD_REF_REORDERING_POS_DIFF_L0,
	H264_VLD_REF_REORDERING_LONG_TERM_L0,

	H264_VLD_REF_REORDERING_FLAG_L1,
	H264_VLD_REF_REORDERING_OF_PIC_NUMS_IDC_L1,
	H264_VLD_REF_REORDERING_NEG_DIFF_L1,
	H264_VLD_REF_REORDERING_POS_DIFF_L1,
	H264_VLD_REF_REORDERING_LONG_TERM_L1,

	H264_VLD_PRED_WEIGHT_LUMA_DENOM,
	H264_VLD_PRED_WEIGHT_CHROMA_DENOM,
	H264_VLD_PRED_WEIGHT_LUMA_WEIGHT_FLAG_L0,
	H264_VLD_PRED_WEIGHT_LUMA_WEIGHT_L0,
	H264_VLD_PRED_WEIGHT_LUMA_OFFSET_L0,
	H264_VLD_PRED_WEIGHT_CHROMA_WEIGHT_FLAG_L0,
	H264_VLD_PRED_WEIGHT_CHROMA_WEIGHT_U_L0,
	H264_VLD_PRED_WEIGHT_CHROMA_OFFSET_U_L0,
	H264_VLD_PRED_WEIGHT_CHROMA_WEIGHT_V_L0,
	H264_VLD_PRED_WEIGHT_CHROMA_OFFSET_V_L0,

	H264_VLD_PRED_WEIGHT_LUMA_WEIGHT_FLAG_L1,
	H264_VLD_PRED_WEIGHT_LUMA_WEIGHT_L1,
	H264_VLD_PRED_WEIGHT_LUMA_OFFSET_L1,
	H264_VLD_PRED_WEIGHT_CHROMA_WEIGHT_FLAG_L1,
	H264_VLD_PRED_WEIGHT_CHROMA_WEIGHT_U_L1,
	H264_VLD_PRED_WEIGHT_CHROMA_OFFSET_U_L1,
	H264_VLD_PRED_WEIGHT_CHROMA_WEIGHT_V_L1,
	H264_VLD_PRED_WEIGHT_CHROMA_OFFSET_V_L1,

	H264_VLD_DEC_REF_PIC_MARK_IDR,
	H264_VLD_DEC_REF_PIC_MARK_ADAPTIVE_FLAG,
	H264_VLD_DEC_REF_PIC_MARK_MMCO,
	H264_VLD_DEC_REF_PIC_MARK_SHORT_UNUSED,
	H264_VLD_DEC_REF_PIC_MARK_LONG_UNUSED,
	H264_VLD_DEC_REF_PIC_MARK_ASSIGN_LONG_TERM_DPN,
	H264_VLD_DEC_REF_PIC_MARK_ASSIGN_LONG_TERM_LTN,
	H264_VLD_DEC_REF_PIC_MARK_MAX_LONG_INDEX,
	H264_VLD_DEC_REF_PIC_MARK_STORE_AS_LONG_TERM,

	H264_VLD_CABAC_INIT_IDC,
	H264_VLD_SLICE_QP_DELTA,
	H264_VLD_SP_FOR_SWITCH_FLAG,
	H264_VLD_SLICE_QS_DELTA,
	H264_VLD_DISABLE_DEBLOCKING_IDC,
	H264_VLD_SLICE_ALPHA_OFFSET,
	H264_VLD_SLICE_BETA_OFFSET,
	H264_VLD_SLICE_GROUP_CHANGE_CYCLE,

	// Slice Data States
	H264_VLD_RUN,
	H264_CABAC_SKIP_FLAG,
	H264_VLD_MB_TYPE,
	H264_VLD_MB_TYPE_PREFIX,
	H264_VLD_MB_TYPE_SUFFIX,
	H264_VLD_INTRA_PRED_MODE_FLAG,
	H264_VLD_INTRA_PRED_MODE_VALUE,
	H264_VLD_INTRA_CHROMA_PRED_MODE,
	H264_VLD_LIST0_REF_INDEX,
	H264_VLD_LIST1_REF_INDEX,
	H264_VLD_MVD_FORWARD,
	H264_VLD_MVD_FORWARD_PREFIX,
	H264_VLD_MVD_FORWARD_SUFFIX,
	H264_VLD_MVD_BACKWARD,
	H264_VLD_MVD_BACKWARD_PREFIX,
	H264_VLD_MVD_BACKWARD_SUFFIX,
	H264_VLD_CBP,
	H264_VLD_CBP_PREFIX,
	H264_VLD_CBP_SUFFIX,
	H264_VLD_DQUANT,
	H264_VLD_8X8_REGION_TYPE,
	H264_VLD_8X8_LIST0_REF_INDEX,
	H264_VLD_8X8_LIST1_REF_INDEX,
	H264_VLD_8X8_FORWARD_MVD,
	H264_VLD_8X8_FORWARD_MVD_PREFIX,
	H264_VLD_8X8_FORWARD_MVD_SUFFIX,
	H264_VLD_8X8_BACKWARD_MVD,
	H264_VLD_8X8_BACKWARD_MVD_PREFIX,
	H264_VLD_8X8_BACKWARD_MVD_SUFFIX,
	H264_VLD_TCOEFF_LUMA_DC_START,
	H264_VLD_TCOEFF_LUMA_DC_END_OF_BLOCK,
	H264_VLD_TCOEFF_LUMA_START,
	H264_VLD_TCOEFF_LUMA_END_OF_BLOCK,
	H264_VLD_TCOEFF_CHROMA_DC_START,
	H264_VLD_TCOEFF_CHROMA_DC_END_OF_BLOCK,
	H264_VLD_TCOEFF_CHROMA_AC_START,
	H264_VLD_TCOEFF_CHROMA_AC_END_OF_BLOCK,
	H264_VLD_TCOEFF_CAVLC_COEFFICIENT_TOKEN,
	H264_VLD_TCOEFF_CAVLC_TRAILING_ONES_SIGN,
	H264_VLD_TCOEFF_CAVLC_COEFFICIENT_LEVEL,
	H264_VLD_TCOEFF_CAVLC_TOTAL_ZEROS,
	H264_VLD_TCOEFF_CAVLC_RUN_BEFORE,
	H264_VLD_I_PCM_BYTE_ALIGNMENT,
	H264_VLD_I_PCM_Y_DATA,
	H264_VLD_I_PCM_U_DATA,
	H264_VLD_I_PCM_V_DATA,
	H264_CABAC_CODED_BLOCK_FLAG,
	H264_CABAC_SIGNIFICANT_COEFF_FLAG,
	H264_CABAC_LAST_SIGNIFICANT_COEFF_FLAG,
	H264_CABAC_ABS_LEVEL_MINUS_ONE,
	H264_CABAC_ABS_LEVEL_MINUS_ONE_PREFIX,
	H264_CABAC_ABS_LEVEL_MINUS_ONE_SUFFIX,
	H264_CABAC_SIGN_FLAG,
	H264_VLD_END_OF_SLICE_FLAG,
	H264_VLD_FIELD_MB_DECODING_FLAG
}	h264_vld_state_t;
*/
typedef enum
{
	H264_BASELINE_PROFILE = 66,
	H264_MAIN_PROFILE = 77,
	H264_EXTENDED_PROFILE = 88,
	H264_HIGH_PROFILE = 100,
	H264_HIGH_10_PROFILE = 110,
	H264_HIGH_422_PROFILE = 122,
	H264_HIGH_444_PROFILE = 144,
	H264_UNKNOWN_PROFILE
}	h264_profile_type_t;

typedef enum
{
	H264_LOW_UNSPECIFIED_NAL_UNIT_TYPE,
	H264_CODED_SLICE_NO_DP,
	H264_CODED_DATA_PARTITION_A,
	H264_CODED_DATA_PARTITION_B,
	H264_CODED_DATA_PARTITION_C,
	H264_CODED_SLICE_IDR,
	H264_SEI_NAL_UNIT_TYPE,
	H264_SEQUENCE_PARAMETER_SET,
	H264_PICTURE_PARAMETER_SET,
	H264_PICTURE_DELIMITER,
	H264_END_OF_SEQUENCE,
	H264_END_OF_STREAM,
	H264_FILLER_DATA,
	H264_HIGH_RESERVED_NAL_UNIT_TYPE
}	h264_NAL_unit_type_t;

typedef enum
{
	H264_P_SLICE,
	H264_B_SLICE_NOT_BaseLine,
	H264_I_SLICE,
	H264_SP_SLICE_NOT_BaseLine,
	H264_SI_SLICE_NOT_BaseLine,
	H264_ALL_P_SLICE,
	H264_ALL_B_SLICE_NOT_BaseLine,
	H264_ALL_I_SLICE,
	H264_ALL_SP_SLICE_NOT_BaseLine,
	H264_ALL_SI_SLICE_NOT_BaseLine,
	H264_UNKNOWN_SLICE
}	h264_slice_type_t;

typedef enum
{
	H264_INTER_16X16,
	H264_INTER_16X8,
	H264_INTER_8X16,
	H264_INTER_8X8_MULTI_REF,
	H264_INTER_8X8_ZERO_REF,
	H264_INTRA_4X4,
	H264_INTRA_16X16,
	H264_DIRECT,
	H264_SKIPPED,
	H264_S_INTRA_4X4,
	H264_I_PCM,
	H264_UNKNOWN_MB_TYPE
}	h264_mb_type_t;

typedef enum
{
	H264_B_DIRECT_16X16,
	H264_B_INTER_16X16_L0,
	H264_B_INTER_16X16_L1,
	H264_B_INTER_16X16_BI,
	H264_B_INTER_16X8_L0_L0,
	H264_B_INTER_8X16_L0_L0,
	H264_B_INTER_16X8_L1_L1,
	H264_B_INTER_8X16_L1_L1,
	H264_B_INTER_16X8_L0_L1,
	H264_B_INTER_8X16_L0_L1,
	H264_B_INTER_16X8_L1_L0,
	H264_B_INTER_8X16_L1_L0,
	H264_B_INTER_16X8_L0_BI,
	H264_B_INTER_8X16_L0_BI,
	H264_B_INTER_16X8_L1_BI,
	H264_B_INTER_8X16_L1_BI,
	H264_B_INTER_16X8_BI_L0,
	H264_B_INTER_8X16_BI_L0,
	H264_B_INTER_16X8_BI_L1,
	H264_B_INTER_8X16_BI_L1,
	H264_B_INTER_16X8_BI_BI,
	H264_B_INTER_8X16_BI_BI,
	H264_B_INTER_8X8,
	H264_B_INTRA_4X4,
	H264_B_INTRA_16X16,
	H264_B_I_PCM,
	H264_B_UNKNOWN_MB_TYPE
}	h264_b_mb_type_t;

// The order of the following enum must be the order in the P picture code table
// to allow the direct mapping from UVLC codeword to partition mode
typedef enum
{
	H264_8X8_PARTITION,
	H264_8X4_PARTITION,
	H264_4X8_PARTITION,
	H264_4X4_PARTITION,
	H264_8X8_DIRECT_PARTITION,
	H264_UNKNOWN_PARTITION_MODE
}	h264_8x8_partition_mode_type_t;

typedef enum
{
	H264_UNKNOWN_REGION,
	H264_FORWARD_REGION,
	H264_BACKWARD_REGION,
	H264_BIDIRECTIONAL_REGION,
	H264_INTRA_REGION,
	H264_DIRECT_REGION		// Has to be translated to H264_BIDIRECTIONAL before use
}	h264_8x8_partition_direction_type_t;

typedef enum
{
	H264_16X16,
	H264_16X8,
	H264_8X16,
	H264_8X8,
	H264_8X4,
	H264_4X8,
	H264_4X4,
	H264_UNKNOWN_SHAPE_TYPE
}	h264_block_shape_type_t;


typedef enum	
{
	H264_RMPNI_NEGATIVE_ADPN,
	H264_RMPNI_POSITIVE_ADPN,
	H264_RMPNI_LPIR,
	H264_RMPNI_END_OF_LOOP,
	H264_RMPNI_UNKNOWN
}	h264_RMPNI_type;


typedef enum
{
	H264_LUMA_DC,
	H264_LUMA_AC,
	H264_CHROMA_DC,
	H264_CHROMA_AC,
	H264_LUMA_8X8
}	h264_block_t;

typedef enum
{
	WAITING_FOR_OR_CODING_KEY_FRAME,	// was NOT_ENCODING_B_PICTURE
	CODING_STORED_FRAME					// was ENCODING_B_PICTURE
} h264_gop_encoding_state_type;

typedef enum
{
	H264_CENTRE_EDGE,
	H264_LEFT_EDGE,
	H264_TOP_EDGE
} h264_filter_edge_type;

typedef enum
{
	H264_FRAME_PICTURE,
	H264_TOP_FIELD_PICTURE,
	H264_BOTTOM_FIELD_PICTURE
} h264_picture_type;

typedef enum
{
	H264_FRAME_STRUCTURE,
	H264_FIELD_STRUCTURE,
	H264_ADAPTIVE_FRAME_STRUCTURE
} h264_picture_structure_type;



typedef enum
{
	H264_FRAME_CODING,
	H264_FIELD_CODING,
	H264_FRAME_FIELD_CODING,
	H264_MACROBLOCK_ADAPTIVE
} h264_interlaced_encoding_mode_type;

enum h264_direction_type
{
	H264_FORWARD, 
	H264_BACKWARD
};

enum h264_mv_component_type
{
	H264_HORIZONTAL,
	H264_VERTICAL
};

#endif // MP4_ENUM_TYPES_H

/*
--------------------------------------------------------------------------------
End of file.
--------------------------------------------------------------------------------
*/
